                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             21   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             22   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             23   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             25   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             26   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             27   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             28   
0000             29   ;---------------------------------;
0000             30   ; Define any buttons & pins here  ;
0000             31   ;---------------------------------;
0000             32   SOUND_OUT   equ p1.7 ; speaker pin
0000             33   PWM_OUT    EQU P1.0 ; Logic 1 = oven on
0000             34   ;---------------------------------------------
0000             35   
0000             36   ORG 0x0000
0000 0206D7      37            ljmp main
0003             38   
0003             39   ; External interrupt 0 vector (not used in this code)
0003             40   org 0x0003
0003 32          41            reti
0004             42   
0004             43   ; Timer/Counter 0 overflow interrupt vector
000B             44   org 0x000B
000B 0203F7      45            ljmp Timer0_ISR
000E             46   
000E             47   ; External interrupt 1 vector (not used in this code)
0013             48   org 0x0013
0013 32          49            reti
0014             50   
0014             51   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             52   org 0x001B
001B 32          53            reti
001C             54   
001C             55   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             56   org 0x0023 
0023 32          57            reti
0024             58            
0024             59   ; Timer/Counter 2 overflow interrupt vector
002B             60   org 0x002B
002B 020424      61            ljmp Timer2_ISR
002E             62   
002E             63   ;---------------------------------;
002E             64   ; Define any constant string here ;
002E             65   ;---------------------------------;
002E             66   ;                          1234567890123456    <- This helps determine the location of the counter
002E 546F3D78    67   To_Message:        db 'To=xxxC Tj= 22C ', 0
     78784320
     546A3D20
     32324320
     00
003F 73787878    68   Time_temp_display:db 'sxxx,xx rxxx,xx ', 0 ; soak temp,time reflow temp,time
     2C787820
     72787878
     2C787820
     00
0050 52616D70    69   Ramp_to_soak:      db 'RampToSoak s=xxx', 0 ; state 1 display
     546F536F
     616B2073
     3D787878
     00
0061 536F616B    70   Soak_display:      db 'Soak               s=xxx', 0 ; state 2 display
     20090920
     733D7878
     7800
006F 52616D70    71   Ramp_to_peak:      db 'RampToPeak s=xxx', 0 ; state 3 display
     546F5065
     616B2073
     3D787878
     00
0080 5265666C    72   Reflow_display:   db 'Reflow      s=xxx', 0 ; state 4 display
     6F772009
     20733D78
     787800
008F 436F6F6C    73   Cooling_display:  db 'Cooling     s=xxx', 0 ; state 5 display
     696E6720
     0920733D
     78787800
009F             74   ;---------------------------------------------
009F             75   cseg
009F             76   
009F             77   LCD_RS equ P1.3
009F             78   LCD_E  equ P1.4
009F             79   LCD_D4 equ P0.0
009F             80   LCD_D5 equ P0.1
009F             81   LCD_D6 equ P0.2
009F             82   LCD_D7 equ P0.3
009F             83   
                 85   $LIST
0171             87   
0171             88   ;---------------------------------;
0171             89   ; Define variables here           ;
0171             90   ;---------------------------------;
0171             91   ; These register definitions needed by 'math32.inc'
0030             92   DSEG at 30H
0030             93   x:   ds 4
0034             94   y:   ds 4
0038             95   bcd: ds 5   ;temperature variable for reading
003D             96   Count1ms:     ds 2 ; Used to determine when one second has passed
003F             97   seconds: ds 1
0040             98   VLED_ADC: ds 2
0042             99   reflow_time: ds 1 ; time parameter for reflow    
0043            100   reflow_temp: ds 1 ; temp parameter for reflow
0044            101   soak_time: ds 1 ; time parameter for soak
0045            102   soak_temp: ds 1 ; temp parameter for soak
0046            103   pwm_counter: ds 1 ; power counter
0047            104   pwm: ds 1 ; variable to count the power percentage
0048            105   temp: ds 3
004B            106   FSM_state: ds 1
004C            107   ;---------------------------------------------
004C            108   
004C            109   ;---------------------------------;
004C            110   ; Define flags here               ;
004C            111   ;---------------------------------;
0000            112   BSEG
0000            113   mf: dbit 1
0001            114   s_flag: dbit 1 ; Set to one in the ISR every time 1000 ms had passed
0002            115   PB0: dbit 1      ; start/stop
0003            116   PB1: dbit 1      ; increment reflow time
0004            117   PB2: dbit 1      ; increment reflow temp
0005            118   PB3: dbit 1      ; increment soak time
0006            119   PB4: dbit 1      ; increment soak temp
0007            120   FSM_start_flag: dbit 1 ; once it starts the timer2 will start checking for stop pushbutton
0008            121   start_stop_flag: dbit 1 ; Set to one if button is pressed to start, press again to stop
0009            122   ;---------------------------------------------
0009            123   
                546   $LIST
                125   $LIST
03E1            127   
03E1            128   ;---------------------------------;
03E1            129   ; Routine to initialize the ISR   ;
03E1            130   ; for timer 0                     ;
03E1            131   ;---------------------------------;
03E1            132   Timer0_Init:
03E1 438E08     133            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
03E4 E589       134            mov a, TMOD
03E6 54F0       135            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03E8 4401       136            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03EA F589       137            mov TMOD, a
03EC 758CF0     138            mov TH0, #high(TIMER0_RELOAD)
03EF 758A2C     139            mov TL0, #low(TIMER0_RELOAD)
03F2            140            ; Enable the timer and interrupts
03F2 D2A9       141       setb ET0  ; Enable timer 0 interrupt
03F4 D28C       142       setb TR0  ; Start timer 0
03F6 22         143            ret
03F7            144   
03F7            145   ;---------------------------------;
03F7            146   ; ISR for timer 0.  Set to execute;
03F7            147   ; every 1/4096Hz to generate a    ;
03F7            148   ; 2048 Hz wave at pin SOUND_OUT   ;
03F7            149   ;---------------------------------;
03F7            150   Timer0_ISR:
03F7            151            ;clr TF0  ; According to the data sheet this is done for us already.
03F7            152            ; Timer 0 doesn't have 16-bit auto-reload, so
03F7 C28C       153            clr TR0
03F9 758CF0     154            mov TH0, #high(TIMER0_RELOAD)
03FC 758A2C     155            mov TL0, #low(TIMER0_RELOAD)
03FF D28C       156            setb TR0
0401 B297       157            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0403 32         158            reti
0404            159   
0404            160   ;---------------------------------;
0404            161   ; Routine to initialize the ISR   ;
0404            162   ; for timer 2                     ;
0404            163   ;---------------------------------;
0404            164   Timer2_Init:
0404 75C800     165            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0407 75CDBF     166            mov TH2, #high(TIMER2_RELOAD)
040A 75CC28     167            mov TL2, #low(TIMER2_RELOAD)
040D            168            ; Set the reload value
040D 43C980     169            orl T2MOD, #0x80 ; Enable timer 2 autoreload
0410 75CBBF     170            mov RCMP2H, #high(TIMER2_RELOAD)
0413 75CA28     171            mov RCMP2L, #low(TIMER2_RELOAD)
0416            172            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0416 E4         173            clr a
0417 F53D       174            mov Count1ms+0, a
0419 F53E       175            mov Count1ms+1, a
041B 754700     176            mov pwm, #0
041E            177            ; Enable the timer and interrupts
041E 439B80     178            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0421 D2CA       179       setb TR2  ; Enable timer 2
0423 22         180            ret
0424            181   
0424            182   ;---------------------------------;
0424            183   ; ISR for timer 2 ;
0424            184   ;---------------------------------;
0424            185   Timer2_ISR:
0424 C2CF       186            clr TF2 ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR. It is bit addressable.
0426 B284       187            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0428            188                    
0428            189            ; The two registers used in the ISR must be saved in the stack
0428 C0D0       190            push psw
042A C0E0       191            push acc
042C 0546       192            inc pwm_counter
042E C3         193            clr c
042F E547       194            mov a, pwm
0431 9546       195            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0433 B3         196            cpl c
0434 9290       197            mov PWM_OUT, c
0436 E546       198            mov a, pwm_counter
0438 B46407     199            cjne a, #100, Timer2_ISR_done
043B 754600     200            mov pwm_counter, #0
043E 053F       201            inc seconds
0440 D201       202            setb s_flag
0442            203            
0442            204            
0442            205            
0442            206   ;        jb FSM_start_flag, check_stop
0442            207            
0442            208   Timer2_ISR_done:
0442            209   
0442 D0E0       210            pop acc
0444 D0D0       211            pop psw
0446 32         212            reti
0447            213   
0447            214   ; check_stop:
0447            215   ;        setb PB4
0447            216   ;        ; The input pin used to check set to '1'
0447            217   ;        setb P1.5
0447            218   ;        clr P0.3
0447            219   ;        jb P1.5, stop_PB_Done
0447            220   ;        ; Debounce
0447            221   ;        mov R2, #50
0447            222   ;        lcall waitms
0447            223   ;        jb P1.5, stop_PB_Done
0447            224   ;        setb P0.3
0447            225   ;        clr P0.3
0447            226   ;        mov c, P1.5
0447            227   ;        mov PB0, c
0447            228   ;        setb P0.3
0447            229   ;        jnb PB0, start_stop_timer
0447            230            
0447            231   ; stop_PB_Done:
0447            232   ;        ljmp Timer2_ISR_done
0447            233   ; start_stop_timer:
0447            234   ;        cpl start_stop_flag
0447            235   ;        sjmp stop_PB_Done
0447            236   
0447            237   ;---------------------------------;
0447            238   ; Temperature senseor function    ;
0447            239   ;---------------------------------;
0447            240   Init_All:
0447            241            ; Configure all the pins for biderectional I/O
0447 75AC00     242            mov     P3M1, #0x00
044A 75AD00     243            mov     P3M2, #0x00
044D 75B300     244            mov     P1M1, #0x00
0450 75B400     245            mov     P1M2, #0x00
0453 75B100     246            mov     P0M1, #0x00
0456 75B200     247            mov     P0M2, #0x00
0459            248            
0459 438E10     249            orl     CKCON, #0x10 ; CLK is the input for timer 1
045C 438780     250            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
045F 759852     251            mov     SCON, #0x52
0462 53C4DF     252            anl     T3CON, #0b11011111
0465 53890F     253            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0468 438920     254            orl     TMOD, #0x20 ; Timer 1 Mode 2
046B 758DF7     255            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
046E D28E       256            setb TR1
0470            257            
0470            258            ; Using timer 0 for delay functions.  Initialize here:
0470 C28C       259            clr     TR0 ; Stop timer 0
0472 438E08     260            orl     CKCON,#0x08 ; CLK is the input for timer 0
0475 5389F0     261            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0478 438901     262            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
047B            263            
047B            264            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
047B 43B382     265            orl     P1M1, #0b10000010
047E 53B47D     266            anl     P1M2, #0b01111101
0481            267            
0481            268            ; Initialize and start the ADC:
0481 53E8F0     269            anl ADCCON0, #0xF0
0484 43E807     270            orl ADCCON0, #0x07 ; Select channel 7
0487            271            ; AINDIDS select if some pins are analog inputs or digital I/O:
0487 75F600     272            mov AINDIDS, #0x00 ; Disable all analog inputs
048A 43F681     273            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
048D 43E101     274            orl ADCCON1, #0x01 ; Enable ADC
0490            275            
0490 22         276            ret
0491            277   
0491            278   wait_1ms:
0491 C28C       279            clr     TR0 ; Stop timer 0
0493 C28D       280            clr     TF0 ; Clear overflow flag
0495 758CBF     281            mov     TH0, #high(TIMER0_RELOAD_1MS)
0498 758A28     282            mov     TL0,#low(TIMER0_RELOAD_1MS)
049B D28C       283            setb TR0
049D 308DFD     284            jnb     TF0, $ ; Wait for overflow
04A0 22         285            ret
04A1            286   
04A1            287   ; Wait the number of miliseconds in R2
04A1            288   waitms:
04A1 120491     289            lcall wait_1ms
04A4 DAFB       290            djnz R2, waitms
04A6 22         291            ret
04A7            292   
04A7            293   ;---------------------------------;
04A7            294   ;         5_pushbuttons function               ;
04A7            295   ;---------------------------------;
04A7            296   LCD_PB:
04A7            297            ; Set variables to 1: 'no push button pressed'
04A7 D202       298            setb PB0
04A9 D203       299            setb PB1
04AB D204       300            setb PB2
04AD D205       301            setb PB3
04AF D206       302            setb PB4
04B1            303            ; The input pin used to check set to '1'
04B1 D295       304            setb P1.5
04B3            305            
04B3            306            ; Check if any push button is pressed
04B3 C280       307            clr P0.0
04B5 C281       308            clr P0.1
04B7 C282       309            clr P0.2
04B9 C283       310            clr P0.3
04BB C293       311            clr P1.3
04BD 209549     312            jb P1.5, LCD_PB_Done
04C0            313   
04C0            314            ; Debounce
04C0 7A32       315            mov R2, #50
04C2 1204A1     316            lcall waitms
04C5 209541     317            jb P1.5, LCD_PB_Done
04C8            318   
04C8            319            ; Set the LCD data pins to logic 1
04C8 D280       320            setb P0.0
04CA D281       321            setb P0.1
04CC D282       322            setb P0.2
04CE D283       323            setb P0.3
04D0 D293       324            setb P1.3
04D2            325            
04D2            326            ; Check the push buttons one by one
04D2 C293       327            clr P1.3
04D4 A295       328            mov c, P1.5
04D6 9206       329            mov PB4, c
04D8 D293       330            setb P1.3
04DA 300632     331            jnb PB4,increment_soak_temp
04DD            332   
04DD C280       333            clr P0.0
04DF A295       334            mov c, P1.5
04E1 9205       335            mov PB3, c
04E3 D280       336            setb P0.0
04E5 300533     337            jnb PB3, increment_soak_time
04E8            338            
04E8 C281       339            clr P0.1
04EA A295       340            mov c, P1.5
04EC 9204       341            mov PB2, c
04EE D281       342            setb P0.1
04F0 300434     343            jnb PB2, increment_reflow_temp
04F3            344            
04F3 C282       345            clr P0.2
04F5 A295       346            mov c, P1.5
04F7 9203       347            mov PB1, c
04F9 D282       348            setb P0.2
04FB 300335     349            jnb PB1, increment_reflow_time
04FE            350            
04FE C283       351            clr P0.3
0500 A295       352            mov c, P1.5
0502 9202       353            mov PB0, c
0504 D283       354            setb P0.3
0506 300236     355            jnb PB0, start_stop
0509            356   
0509            357   LCD_PB_Done:
0509 7A14       358            mov r2,#20
050B 1204A1     359            lcall waitms            
050E 22         360            ret
050F            361   
050F            362   increment_soak_temp:
050F 0545       363            inc soak_temp
0511 E545       364            mov a, soak_temp
0513 B4F0F3     365            cjne a, #0xF0, LCD_PB_Done
0516 754500     366            mov soak_temp, #0x00
0519 80EE       367            sjmp LCD_PB_Done
051B            368   increment_soak_time:
051B 0544       369            inc soak_time
051D E544       370            mov a, soak_time
051F B478E7     371            cjne a, #0x78, LCD_PB_Done
0522 754400     372            mov soak_time, #0x00
0525 80E2       373            sjmp LCD_PB_Done
0527            374   increment_reflow_temp: 
0527 0543       375            inc reflow_temp
0529 E543       376            mov a, reflow_temp
052B B4F0DB     377            cjne a, #0xF0, LCD_PB_Done
052E 754300     378            mov reflow_temp, #0x00
0531 80D6       379            sjmp LCD_PB_Done
0533            380   increment_reflow_time:
0533 0542       381            inc reflow_time
0535 E542       382            mov a, reflow_time
0537 B44BCF     383            cjne a, #0x4B, LCD_PB_Done
053A 754200     384            mov reflow_time, #0x00
053D 80CA       385            sjmp LCD_PB_Done
053F            386   
053F            387   start_stop:
053F B208       388            cpl start_stop_flag
0541 80C6       389            sjmp LCD_PB_Done
0543            390   
0543            391   ; We can display a number any way we want.  In this case with
0543            392   ; four decimal places.
0543            393   Display_formated_BCD:
0543 C0E0       394            push acc
0545 7404       394            mov a, #4
0547 14         394            dec a
0548 120138     394            lcall ?Set_Cursor_1 ; Select column and row
054B D0E0       394            pop acc ; display To
054D C000       395            push ar0
054F A83B       395            mov r0, bcd+3
0551 12013D     395            lcall ?Display_BCD
0554 D000       395            pop ar0
0556 C000       396            push ar0
0558 A83A       396            mov r0, bcd+2
055A 12013D     396            lcall ?Display_BCD
055D D000       396            pop ar0 ;this is just in case temperatures exceed 100C and we're in deg F
055F            397            
055F            398   
055F            399   
055F            400            ;send the BCD value to the MATLAB script
055F C000       401            push ar0
0561 A83B       401            mov r0, bcd+3
0563 12015B     401            lcall ?Send_BCD
0566 D000       401            pop ar0
0568 C000       402            push ar0
056A A83A       402            mov r0, bcd+2
056C 12015B     402            lcall ?Send_BCD
056F D000       402            pop ar0
0571 C000       403            push ar0
0573 A839       403            mov r0, bcd+1
0575 12015B     403            lcall ?Send_BCD
0578 D000       403            pop ar0
057A 740D       404            mov a, #'\r'
057C 120153     405            lcall putchar
057F 740A       406            mov a, #'\n'
0581 120153     407            lcall putchar
0584            408            ;Set_Cursor(1, 13)
0584            409            ;Send_Constant_String(#22) ; display Tj=22
0584            410            
0584 C0E0       411            push acc
0586 740E       411            mov a, #14
0588 14         411            dec a
0589 120136     411            lcall ?Set_Cursor_2 ; Select column and row
058C D0E0       411            pop acc
058E E53F       412            mov a,seconds
0590 120594     413            lcall SendToLCD
0593            414            
0593 22         415            ret
0594            416   
0594            417   SendToLCD:
0594 75F064     418   mov b, #100
0597 84         419   div ab
0598 4430       420   orl a, #0x30 ; Convert hundreds to ASCII
059A 1200EE     421   lcall ?WriteData ; Send to LCD
059D E5F0       422   mov a, b ; Remainder is in register b
059F 75F00A     423   mov b, #10
05A2 84         424   div ab
05A3 4430       425   orl a, #0x30 ; Convert tens to ASCII
05A5 1200EE     426   lcall ?WriteData; Send to LCD
05A8 E5F0       427   mov a, b
05AA 4430       428   orl a, #0x30 ; Convert units to ASCII
05AC 1200EE     429   lcall ?WriteData; Send to LCD
05AF 22         430   ret
05B0            431   
05B0            432   ;-------------------------------------------------;
05B0            433   ; Display values from the pushbutton to the LCD   ;
05B0            434   ;-------------------------------------------------;
05B0            435   
05B0            436   Display_PushButtons_LCD:
05B0 C0E0       437            push acc
05B2 7402       437            mov a, #2
05B4 14         437            dec a
05B5 120136     437            lcall ?Set_Cursor_2 ; Select column and row
05B8 D0E0       437            pop acc
05BA E545       438            mov a, soak_temp
05BC 120594     439            lcall SendToLCD
05BF            440            
05BF C0E0       441            push acc
05C1 7406       441            mov a, #6
05C3 14         441            dec a
05C4 120136     441            lcall ?Set_Cursor_2 ; Select column and row
05C7 D0E0       441            pop acc
05C9 E544       442            mov a, soak_time
05CB 120594     443            lcall SendToLCD
05CE            444       
05CE C0E0       445            push acc
05D0 740A       445            mov a, #10
05D2 14         445            dec a
05D3 120136     445            lcall ?Set_Cursor_2 ; Select column and row
05D6 D0E0       445            pop acc
05D8 E543       446       mov a, reflow_temp
05DA 120594     447            lcall SendToLCD
05DD            448       
05DD C0E0       449            push acc
05DF 740E       449            mov a, #14
05E1 14         449            dec a
05E2 120136     449            lcall ?Set_Cursor_2 ; Select column and row
05E5 D0E0       449            pop acc
05E7 E542       450       mov a, reflow_time
05E9 120594     451            lcall SendToLCD
05EC            452            
05EC 22         453            ret
05ED            454   
05ED            455   
05ED            456   ;-------------------------------------------------;
05ED            457   ; Display all values and temperatures to the LCD  ;
05ED            458   ;-------------------------------------------------;
05ED            459   Display_Data:
05ED C2EF       460            clr ADCF
05EF D2EE       461            setb ADCS ;  ADC start trigger signal
05F1 30EFFD     462       jnb ADCF, $ ; Wait for conversion complete
05F4            463       
05F4            464       ; Read the ADC result and store in [R1, R0]
05F4 E5C3       465       mov a, ADCRH   
05F6 C4         466       swap a
05F7 C0E0       467       push acc
05F9 540F       468       anl a, #0x0f
05FB F9         469       mov R1, a
05FC D0E0       470       pop acc
05FE 54F0       471       anl a, #0xf0
0600 45C2       472       orl a, ADCRL
0602 F8         473       mov R0, A
0603            474       
0603            475       ; Convert to voltage
0603 8830       476            mov x+0, R0
0605 8931       477            mov x+1, R1
0607            478            ; Pad other bits with zero
0607 753200     479            mov x+2, #0
060A 753300     480            mov x+3, #0
060D            481            
060D            482            ;lcall div32 ; Get V_out
060D            483            ; ; Calculate Temp based on V_out
060D            484            ; Load_y(27300) ; The reference temp K
060D            485            ; lcall sub32 ; Get Temp*0.01
060D            486            ; ; Change Temp*0.01 to Temp
060D            487            ; Load_y(100)
060D            488            ; lcall mul32
060D            489   
060D 75347C     490            mov y+0, #low (50300 % 0x10000) 
0610 7535C4     490            mov y+1, #high(50300 % 0x10000) 
0613 753600     490            mov y+2, #low (50300 / 0x10000) 
0616 753700     490            mov y+3, #high(50300 / 0x10000)  ; VCC voltage measured (equals 4.99V)
0619 1202EB     491            lcall mul32 ;multiplying ADC * Vref
061C 7534FF     492            mov y+0, #low (4095 % 0x10000) 
061F 75350F     492            mov y+1, #high(4095 % 0x10000) 
0622 753600     492            mov y+2, #low (4095 / 0x10000) 
0625 753700     492            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
0628 120378     493            lcall div32 ;now doing (ADC*Vref)/(4095)
062B            494            
062B 7534E8     495            mov y+0, #low (1000 % 0x10000) 
062E 753503     495            mov y+1, #high(1000 % 0x10000) 
0631 753600     495            mov y+2, #low (1000 / 0x10000) 
0634 753700     495            mov y+3, #high(1000 / 0x10000)  ; for converting volt to microvolt
0637 1202EB     496            lcall mul32 ;multiplying volts
063A            497            
063A 75340A     498            mov y+0, #low (10 % 0x10000) 
063D 753500     498            mov y+1, #high(10 % 0x10000) 
0640 753600     498            mov y+2, #low (10 / 0x10000) 
0643 753700     498            mov y+3, #high(10 / 0x10000) 
0646 1202EB     499            lcall mul32
0649            500            
0649            501            ;convert to temperature
0649 7534D0     502            mov y+0, #low (21200 % 0x10000) 
064C 753552     502            mov y+1, #high(21200 % 0x10000) 
064F 753600     502            mov y+2, #low (21200 / 0x10000) 
0652 753700     502            mov y+3, #high(21200 / 0x10000)  ;divide by the gain 
0655 120378     503            lcall div32 
0658 753429     504            mov y+0, #low (41 % 0x10000) 
065B 753500     504            mov y+1, #high(41 % 0x10000) 
065E 753600     504            mov y+2, #low (41 / 0x10000) 
0661 753700     504            mov y+3, #high(41 / 0x10000) ;load y = 41
0664 120378     505            lcall div32 ;divide by 41
0667            506            
0667 753410     507            mov y+0, #low (10000 % 0x10000) 
066A 753527     507            mov y+1, #high(10000 % 0x10000) 
066D 753600     507            mov y+2, #low (10000 / 0x10000) 
0670 753700     507            mov y+3, #high(10000 / 0x10000) 
0673 1202EB     508            lcall mul32
0676            509            
0676 753460     510            mov y+0, #low (220000 % 0x10000) 
0679 75355B     510            mov y+1, #high(220000 % 0x10000) 
067C 753603     510            mov y+2, #low (220000 / 0x10000) 
067F 753700     510            mov y+3, #high(220000 / 0x10000)  ;cold junction 19 deg C
0682 120236     511            lcall add32
0685            512   
0685            513   ; Convert to BCD and display
0685 120171     514            lcall hex2bcd
0688 120543     515            lcall Display_formated_BCD
068B            516   
068B 32         517            reti
068C            518   
068C            519   ;-----------------------------------------------------------------------------;
068C            520   ;Grabs the value in register a and then compares it to the current temperature;
068C            521   ;-----------------------------------------------------------------------------;
068C            522   
068C            523   Compare_temp:
068C 853A48     524            mov temp+0, bcd+2
068F 853B49     525            mov temp+1, bcd+3
0692 854838     526            mov bcd+0, temp+0
0695 854939     527            mov bcd+1, temp+1
0698 753A00     528            mov bcd+2,#0
069B 753B00     529            mov bcd+3,#0
069E 753C00     530            mov bcd+4,#0
06A1            531            
06A1 1201FA     532            lcall bcd2hex
06A4            533            
06A4 853034     534            mov y+0,x+0
06A7 853135     535            mov y+1,x+1
06AA 853236     536            mov y+2,x+2
06AD 853337     537            mov y+3,x+3
06B0            538            
06B0 F530       539            mov x+0,a
06B2 753100     540            mov x+1,#0
06B5 753200     541            mov x+2,#0
06B8 753300     542            mov x+3,#0
06BB            543            
06BB 120171     544            lcall hex2bcd
06BE 1202E1     545            lcall x_lteq_y
06C1            546   
06C1 32         547            reti
06C2            548   
06C2            549   Wait_1sec:
06C2            550            ; Wait 500 ms between conversions
06C2 7AFA       551            mov R2, #250
06C4 1204A1     552            lcall waitms
06C7 7AFA       553            mov R2, #250
06C9 1204A1     554            lcall waitms
06CC            555            ; Wait 500 ms between conversions
06CC 7AFA       556            mov R2, #250
06CE 1204A1     557            lcall waitms
06D1 7AFA       558            mov R2, #250
06D3 1204A1     559            lcall waitms
06D6 32         560            reti
06D7            561   
06D7            562   main:
06D7 75817F     563            mov sp, #0x7f
06DA 120447     564            lcall Init_All
06DD 1200F8     565       lcall LCD_4BIT
06E0 1203E1     566       lcall Timer0_Init
06E3 120404     567       lcall Timer2_Init
06E6 D2AF       568       setb EA   ; Enable Global interrupts
06E8            569       ; initial messages in LCD
06E8 C0E0       570            push acc
06EA 7401       570            mov a, #1
06EC 14         570            dec a
06ED 120138     570            lcall ?Set_Cursor_1 ; Select column and row
06F0 D0E0       570            pop acc
06F2 C083       571            push dph
06F4 C082       571            push dpl
06F6 C0E0       571            push acc
06F8 90002E     571            mov dptr, #To_Message
06FB 12012B     571            lcall ?Send_Constant_String
06FE D0E0       571            pop acc
0700 D082       571            pop dpl
0702 D083       571            pop dph
0704 C0E0       572            push acc
0706 7401       572            mov a, #1
0708 14         572            dec a
0709 120136     572            lcall ?Set_Cursor_2 ; Select column and row
070C D0E0       572            pop acc
070E C083       573            push dph
0710 C082       573            push dpl
0712 C0E0       573            push acc
0714 90003F     573            mov dptr, #Time_temp_display
0717 12012B     573            lcall ?Send_Constant_String
071A D0E0       573            pop acc
071C D082       573            pop dpl
071E D083       573            pop dph
0720 754B00     574       mov FSM_state,#0
0723 753F00     575            mov seconds, #0x00
0726 75458C     576            mov soak_temp, #0x8C ;140
0729 75443C     577            mov soak_time, #0x3C ; 60
072C 7543E6     578            mov reflow_temp, #0xE6 ; 230
072F 75421E     579            mov reflow_time, #0x1E ; 30
0732            580            
0732 C208       581            clr start_stop_flag
0734 C207       582            clr FSM_start_flag
0736            583       
0736            584   ;---------------------------------;
0736            585   ;                FSM     funtion                               ;
0736            586   ;---------------------------------;
0736            587   FSM:
0736 E54B       588       mov a, FSM_state
0738            589   FSM_state0:
0738 B40033     590       cjne a, #0, FSM_state1
073B 754700     591       mov pwm, #0 ; power variable
073E 1204A7     592            lcall LCD_PB ; calls and checks the pushbuttons
0741 1205B0     593            lcall Display_PushButtons_LCD ;Displays values in pushbuttons
0744 300824     594       jnb start_stop_flag, FSM_state0_done
0747 D207       595       setb FSM_start_flag
0749 753F00     596       mov seconds, #0x00     ; set time to 0
074C 754B01     597       mov FSM_state, #1   ; set FSM_state to 1, next state is state1
074F C0E0       598            push acc
0751 7401       598            mov a, #1
0753 14         598            dec a
0754 120136     598            lcall ?Set_Cursor_2 ; Select column and row
0757 D0E0       598            pop acc
0759 C083       599            push dph
075B C082       599            push dpl
075D C0E0       599            push acc
075F 900050     599            mov dptr, #Ramp_to_soak
0762 12012B     599            lcall ?Send_Constant_String
0765 D0E0       599            pop acc
0767 D082       599            pop dpl
0769 D083       599            pop dph
076B            600   FSM_state0_done:
076B 020736     601       ljmp FSM   ;jump back to FSM and reload FSM_state to a
076E            602   
076E            603   FSM_state1:
076E B40144     604       cjne a, #1, FSM_state2
0771 754764     605       mov pwm, #100
0774 C3         606       clr c
0775 300831     607       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
0778 743C       608       mov a, #0x3C
077A 953F       609       subb a, seconds
077C 401A       610       jc abort
077E            611   continue:
077E C3         612       clr c   ; ! i don't know what is c
077F 300113     613            jnb s_flag, FSM_state1_done
0782 C201       614            clr s_flag
0784 1205ED     615            lcall Display_Data
0787 E545       616            mov a, soak_temp    ; set a to soak temp
0789 12068C     617            lcall Compare_temp
078C 300006     618       jnb mf, FSM_state1_done
078F 753F00     619       mov seconds, #0x00     ; set time to 0
0792 754B02     620       mov FSM_state, #2
0795            621   FSM_state1_done:
0795 020736     622       ljmp FSM
0798            623   abort:
0798 7432       624       mov a, #0x32  ; set a to 50 degree
079A 3001F8     625            jnb s_flag, FSM_state1_done
079D 1205ED     626            lcall Display_Data
07A0 12068C     627            lcall Compare_temp
07A3 2000D8     628            jb mf, continue ; if temp is larger then 50 degree, go back to continue
07A6 754B00     629       mov FSM_state, #0   ; abort the FSM
07A9            630   
07A9            631   stop_state:
07A9 C2CA       632       clr TR2
07AB 300805     633       jnb start_stop_flag, stop
07AE D2CA       634            setb TR2
07B0 020736     635            ljmp FSM
07B3            636   
07B3            637   stop:
07B3 80F4       638       sjmp stop_state
07B5            639   
07B5            640   FSM_state2:
07B5 B40238     641       cjne a, #2, FSM_state3
07B8 754714     642       mov pwm, #20
07BB E544       643       mov a, soak_time    ; set a to soak time
07BD C0E0       644            push acc
07BF 7401       644            mov a, #1
07C1 14         644            dec a
07C2 120136     644            lcall ?Set_Cursor_2 ; Select column and row
07C5 D0E0       644            pop acc
07C7 C083       645            push dph
07C9 C082       645            push dpl
07CB C0E0       645            push acc
07CD 900061     645            mov dptr, #Soak_display
07D0 12012B     645            lcall ?Send_Constant_String
07D3 D0E0       645            pop acc
07D5 D082       645            pop dpl
07D7 D083       645            pop dph
07D9 C3         646       clr c   ; ! i don't know what is c 
07DA 300110     647            jnb s_flag, FSM_state2_done
07DD 1205ED     648            lcall Display_Data
07E0 3008C6     649       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
07E3 953F       650       subb a, seconds    ; temp is our currect sec
07E5 5006       651       jnc FSM_state2_done
07E7 753F00     652       mov seconds, #0x00     ; set time to 0
07EA 754B03     653       mov FSM_state, #3
07ED            654   FSM_state2_done:
07ED 020736     655       ljmp FSM
07F0            656   
07F0            657   FSM_state3:
07F0 B40340     658       cjne a, #3, FSM_state4
07F3 754764     659       mov pwm, #100
07F6 C0E0       660            push acc
07F8 7401       660            mov a, #1
07FA 14         660            dec a
07FB 120136     660            lcall ?Set_Cursor_2 ; Select column and row
07FE D0E0       660            pop acc
0800 C083       661            push dph
0802 C082       661            push dpl
0804 C0E0       661            push acc
0806 90006F     661            mov dptr, #Ramp_to_peak
0809 12012B     661            lcall ?Send_Constant_String
080C D0E0       661            pop acc
080E D082       661            pop dpl
0810 D083       661            pop dph
0812 C3         662       clr c   ; ! i don't know what is c 
0813 300893     663       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
0816 300111     664            jnb s_flag, FSM_state3_done
0819 1205ED     665            lcall Display_Data
081C E543       666            mov a, reflow_temp    ; set a to reflow temp
081E 12068C     667            lcall Compare_temp
0821 300006     668       jnb mf, FSM_state3_done
0824 753F00     669       mov seconds, #0x00     ; set time to 0
0827 754B04     670       mov FSM_state, #4
082A            671   FSM_state3_done:
082A 020736     672       ljmp FSM
082D            673            
082D            674   intermediate_state_0:
082D 020738     675            ljmp FSM_state0
0830            676   
0830            677   intermediate_stop_jump:
0830 0207A9     678            ljmp stop_state
0833            679   
0833            680   FSM_state4:
0833 B40438     681       cjne a, #4, FSM_state5
0836 754714     682       mov pwm, #20
0839 E542       683       mov a, reflow_time    ; set a to reflow time
083B C0E0       684            push acc
083D 7401       684            mov a, #1
083F 14         684            dec a
0840 120136     684            lcall ?Set_Cursor_2 ; Select column and row
0843 D0E0       684            pop acc
0845 C083       685            push dph
0847 C082       685            push dpl
0849 C0E0       685            push acc
084B 900080     685            mov dptr, #Reflow_display
084E 12012B     685            lcall ?Send_Constant_String
0851 D0E0       685            pop acc
0853 D082       685            pop dpl
0855 D083       685            pop dph
0857 C3         686       clr c   ; ! i don't know what is c 
0858 300110     687            jnb s_flag, FSM_state4_done
085B 1205ED     688            lcall Display_Data
085E 3008CF     689       jnb start_stop_flag, intermediate_stop_jump; checks the flag if 0, then means stop was pressed, if 1 keep on going
0861 953F       690       subb a, seconds    ; temp is our currect sec
0863 5006       691       jnc FSM_state4_done
0865 753F00     692       mov seconds, #0x00     ; set time to 0
0868 754B05     693       mov FSM_state, #5
086B            694   FSM_state4_done:
086B 020736     695       ljmp FSM
086E            696   
086E            697   FSM_state5:
086E B405BC     698       cjne a, #5, intermediate_state_0
0871 754700     699       mov pwm, #0
0874            700       
0874 C0E0       701            push acc
0876 7401       701            mov a, #1
0878 14         701            dec a
0879 120136     701            lcall ?Set_Cursor_2 ; Select column and row
087C D0E0       701            pop acc
087E C083       702            push dph
0880 C082       702            push dpl
0882 C0E0       702            push acc
0884 90008F     702            mov dptr, #Cooling_display
0887 12012B     702            lcall ?Send_Constant_String
088A D0E0       702            pop acc
088C D082       702            pop dpl
088E D083       702            pop dph
0890 C3         703       clr c   ; ! i don't know what is c
0891 30089C     704       jnb start_stop_flag, intermediate_stop_jump ; checks the flag if 0, then means stop was pressed, if 1 keep on going 
0894 300111     705            jnb s_flag, FSM_state5_done
0897 1205ED     706            lcall Display_Data
089A 743C       707            mov a, #0x3C    ; set a to 60
089C 12068C     708            lcall Compare_temp
089F            709   
089F 200006     710       jb mf, FSM_state5_done
08A2 753F00     711       mov seconds, #0x00     ; set time to 0
08A5 754B00     712       mov FSM_state, #0
08A8            713   FSM_state5_done:
08A8 020736     714       ljmp FSM
08AB            715   EN
