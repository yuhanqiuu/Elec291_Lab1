                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             21   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             22   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             23   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER1_RELOAD     EQU (0x100-(CLK/(BAUD)))
0000             25   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             26   TIMER2_RATE   EQU 100     ; 100Hz, for a timer tick of 1s
0000             27   TIMER2_RELOAD EQU ((65536-(CLK/(16*TIMER2_RATE))))
0000             28   
0000             29   ;---------------------------------;
0000             30   ; Define any buttons & pins here  ;
0000             31   ;---------------------------------;
0000             32   SOUND_OUT   equ p1.7 ; speaker pin
0000             33   PWM_OUT    EQU P1.0 ; Logic 1 = oven on
0000             34   ;---------------------------------------------
0000             35   
0000             36   ORG 0x0000
0000 02078A      37            ljmp main
0003             38   
0003             39   ; External interrupt 0 vector (not used in this code)
0003             40   org 0x0003
0003 32          41            reti
0004             42   
0004             43   ; Timer/Counter 0 overflow interrupt vector
000B             44   org 0x000B
000B 0203EE      45            ljmp Timer0_ISR
000E             46   
000E             47   ; External interrupt 1 vector (not used in this code)
0013             48   org 0x0013
0013 32          49            reti
0014             50   
0014             51   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             52   org 0x001B
001B 32          53            reti
001C             54   
001C             55   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             56   org 0x0023 
0023 32          57            reti
0024             58            
0024             59   ; Timer/Counter 2 overflow interrupt vector
002B             60   org 0x002B
002B 02041B      61            ljmp Timer2_ISR
002E             62   
002E             63   ;---------------------------------;
002E             64   ; Define any constant string here ;
002E             65   ;---------------------------------;
002E             66   ;                          1234567890123456    <- This helps determine the location of the counter
002E 546F3D78    67   To_Message:        db 'To=xxxC Tj= 22C ', 0
     78784320
     546A3D20
     32324320
     00
003F 73787878    68   Time_temp_display:db 'sxxx,xx rxxx,xx ', 0 ; soak temp,time reflow temp,time
     2C787820
     72787878
     2C787820
     00
0050 52616D70    69   Ramp_to_soak:      db 'RampToSoak s=', 0 ; state 1 display
     546F536F
     616B2073
     3D00
005E 536F616B    70   Soak_display:      db 'Soak       s=', 0 ; state 2 display
     20202020
     20202073
     3D00
006C 52616D70    71   Ramp_to_peak:      db 'RampToPeak s=', 0 ; state 3 display
     546F5065
     616B2073
     3D00
007A 5265666C    72   Reflow_display:   db 'Reflow     s=', 0 ; state 4 display
     6F772020
     20202073
     3D00
0088 436F6F6C    73   Cooling_display:  db 'Cooling    s=', 0 ; state 5 display
     696E6720
     20202073
     3D00
0096             74   ;---------------------------------------------
0096             75   cseg
0096             76   
0096             77   LCD_RS equ P1.3
0096             78   LCD_E  equ P1.4
0096             79   LCD_D4 equ P0.0
0096             80   LCD_D5 equ P0.1
0096             81   LCD_D6 equ P0.2
0096             82   LCD_D7 equ P0.3
0096             83   
                 85   $LIST
0168             87   
0168             88   ;---------------------------------;
0168             89   ; Define variables here           ;
0168             90   ;---------------------------------;
0168             91   ; These register definitions needed by 'math32.inc'
0030             92   DSEG at 30H
0030             93   x:   ds 4
0034             94   y:   ds 4
0038             95   bcd: ds 5   ;temperature variable for reading
003D             96   Count1ms:     ds 2 ; Used to determine when one second has passed
003F             97   seconds: ds 1
0040             98   VLED_ADC: ds 2
0042             99   reflow_time: ds 1 ; time parameter for reflow    
0043            100   reflow_temp: ds 1 ; temp parameter for reflow
0044            101   soak_time: ds 1 ; time parameter for soak
0045            102   soak_temp: ds 1 ; temp parameter for soak
0046            103   pwm_counter: ds 1 ; power counter
0047            104   pwm: ds 1 ; variable to count the power percentage
0048            105   temp: ds 3
004B            106   FSM_state: ds 1
004C            107   ;---------------------------------------------
004C            108   
004C            109   ;---------------------------------;
004C            110   ; Define flags here               ;
004C            111   ;---------------------------------;
0000            112   BSEG
0000            113   mf: dbit 1
0001            114   s_flag: dbit 1 ; Set to one in the ISR every time 1000 ms had passed
0002            115   PB0: dbit 1      ; start/stop
0003            116   PB1: dbit 1      ; increment reflow time
0004            117   PB2: dbit 1      ; increment reflow temp
0005            118   PB3: dbit 1      ; increment soak time
0006            119   PB4: dbit 1      ; increment soak temp
0007            120   FSM_start_flag: dbit 1 ; once it starts the timer2 will start checking for stop pushbutton
0008            121   start_stop_flag: dbit 1 ; Set to one if button is pressed to start, press again to stop
0009            122   ;---------------------------------------------
0009            123   
                546   $LIST
                125   $LIST
03D8            127   
03D8            128   ;---------------------------------;
03D8            129   ; Routine to initialize the ISR   ;
03D8            130   ; for timer 0                     ;
03D8            131   ;---------------------------------;
03D8            132   Timer0_Init:
03D8 438E08     133            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
03DB E589       134            mov a, TMOD
03DD 54F0       135            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03DF 4401       136            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03E1 F589       137            mov TMOD, a
03E3 758CF0     138            mov TH0, #high(TIMER0_RELOAD)
03E6 758A2C     139            mov TL0, #low(TIMER0_RELOAD)
03E9            140            ; Enable the timer and interrupts
03E9 D2A9       141       setb ET0  ; Enable timer 0 interrupt
03EB D28C       142       setb TR0  ; Start timer 0
03ED 22         143            ret
03EE            144   
03EE            145   ;---------------------------------;
03EE            146   ; ISR for timer 0.  Set to execute;
03EE            147   ; every 1/4096Hz to generate a    ;
03EE            148   ; 2048 Hz wave at pin SOUND_OUT   ;
03EE            149   ;---------------------------------;
03EE            150   Timer0_ISR:
03EE            151            ;clr TF0  ; According to the data sheet this is done for us already.
03EE            152            ; Timer 0 doesn't have 16-bit auto-reload, so
03EE C28C       153            clr TR0
03F0 758CF0     154            mov TH0, #high(TIMER0_RELOAD)
03F3 758A2C     155            mov TL0, #low(TIMER0_RELOAD)
03F6 D28C       156            setb TR0
03F8 B297       157            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
03FA 32         158            reti
03FB            159   
03FB            160   ;---------------------------------;
03FB            161   ; Routine to initialize the ISR   ;
03FB            162   ; for timer 2                     ;
03FB            163   ;---------------------------------;
03FB            164   Timer2_Init:
03FB 75C800     165            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
03FE 75CDD7     166            mov TH2, #high(TIMER2_RELOAD)
0401 75CC79     167            mov TL2, #low(TIMER2_RELOAD)
0404            168            ; Set the reload value
0404 75C9A0     169            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
0407 75CBD7     170            mov RCMP2H, #high(TIMER2_RELOAD)
040A 75CA79     171            mov RCMP2L, #low(TIMER2_RELOAD)
040D            172            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
040D E4         173            clr a
040E F53D       174            mov Count1ms+0, a
0410 F53E       175            mov Count1ms+1, a
0412 754700     176            mov pwm, #0
0415            177            ; Enable the timer and interrupts
0415 439B80     178            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0418 D2CA       179       setb TR2  ; Enable timer 2
041A 22         180            ret
041B            181   
041B            182   ;---------------------------------;
041B            183   ; ISR for timer 2 ;
041B            184   ;---------------------------------;
041B            185   Timer2_ISR:
041B C2CF       186            clr TF2 ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR. It is bit addressable.
041D B284       187            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
041F            188                    
041F            189            ; The two registers used in the ISR must be saved in the stack
041F C0D0       190            push psw
0421 C0E0       191            push acc
0423 0546       192            inc pwm_counter
0425 C3         193            clr c
0426 E547       194            mov a, pwm
0428 9546       195            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
042A B3         196            cpl c
042B 9290       197            mov PWM_OUT, c
042D E546       198            mov a, pwm_counter
042F            199   
042F B46407     200            cjne a, #100, Timer2_ISR_done
0432 754600     201            mov pwm_counter, #0
0435 053F       202            inc seconds
0437 D201       203            setb s_flag
0439            204            
0439            205            
0439            206            
0439            207   ;        jb FSM_start_flag, check_stop
0439            208            
0439            209   Timer2_ISR_done:
0439            210   
0439 D0E0       211            pop acc
043B D0D0       212            pop psw
043D 32         213            reti
043E            214   
043E            215   ; check_stop:
043E            216   ;        setb PB4
043E            217   ;        ; The input pin used to check set to '1'
043E            218   ;        setb P1.5
043E            219   ;        clr P0.3
043E            220   ;        jb P1.5, stop_PB_Done
043E            221   ;        ; Debounce
043E            222   ;        mov R2, #50
043E            223   ;        lcall waitms
043E            224   ;        jb P1.5, stop_PB_Done
043E            225   ;        setb P0.3
043E            226   ;        clr P0.3
043E            227   ;        mov c, P1.5
043E            228   ;        mov PB0, c
043E            229   ;        setb P0.3
043E            230   ;        jnb PB0, start_stop_timer
043E            231            
043E            232   ; stop_PB_Done:
043E            233   ;        ljmp Timer2_ISR_done
043E            234   ; start_stop_timer:
043E            235   ;        cpl start_stop_flag
043E            236   ;        sjmp stop_PB_Done
043E            237   
043E            238   ;---------------------------------;
043E            239   ; Temperature senseor function    ;
043E            240   ;---------------------------------;
043E            241   Init_All:
043E            242            ; Configure all the pins for biderectional I/O
043E 75AC00     243            mov     P3M1, #0x00
0441 75AD00     244            mov     P3M2, #0x00
0444 75B300     245            mov     P1M1, #0x00
0447 75B400     246            mov     P1M2, #0x00
044A 75B100     247            mov     P0M1, #0x00
044D 75B200     248            mov     P0M2, #0x00
0450            249            
0450 438E10     250            orl     CKCON, #0x10 ; CLK is the input for timer 1
0453 438780     251            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0456 759852     252            mov     SCON, #0x52
0459 53C4DF     253            anl     T3CON, #0b11011111
045C 53890F     254            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
045F 438920     255            orl     TMOD, #0x20 ; Timer 1 Mode 2
0462 758D70     256            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0465 D28E       257            setb TR1
0467            258            
0467            259            ; Using timer 0 for delay functions.  Initialize here:
0467 C28C       260            clr     TR0 ; Stop timer 0
0469 438E08     261            orl     CKCON,#0x08 ; CLK is the input for timer 0
046C 5389F0     262            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
046F 438901     263            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0472            264            
0472            265            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
0472 43B382     266            orl     P1M1, #0b10000010
0475 53B47D     267            anl     P1M2, #0b01111101
0478            268            
0478            269            ; Initialize and start the ADC:
0478 53E8F0     270            anl ADCCON0, #0xF0
047B 43E807     271            orl ADCCON0, #0x07 ; Select channel 7
047E            272            ; AINDIDS select if some pins are analog inputs or digital I/O:
047E 75F600     273            mov AINDIDS, #0x00 ; Disable all analog inputs
0481 43F681     274            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
0484 43E101     275            orl ADCCON1, #0x01 ; Enable ADC
0487            276            
0487 22         277            ret
0488            278   
0488            279   wait_1ms:
0488 C28C       280            clr     TR0 ; Stop timer 0
048A C28D       281            clr     TF0 ; Clear overflow flag
048C 758CBF     282            mov     TH0, #high(TIMER0_RELOAD_1MS)
048F 758A28     283            mov     TL0,#low(TIMER0_RELOAD_1MS)
0492 D28C       284            setb TR0
0494 308DFD     285            jnb     TF0, $ ; Wait for overflow
0497 22         286            ret
0498            287   
0498            288   ; Wait the number of miliseconds in R2
0498            289   waitms:
0498 120488     290            lcall wait_1ms
049B DAFB       291            djnz R2, waitms
049D 22         292            ret
049E            293   
049E            294   ;---------------------------------;
049E            295   ;         5_pushbuttons function               ;
049E            296   ;---------------------------------;
049E            297   LCD_PB:
049E            298            ; Set variables to 1: 'no push button pressed'
049E D202       299            setb PB0
04A0 D203       300            setb PB1
04A2 D204       301            setb PB2
04A4 D205       302            setb PB3
04A6 D206       303            setb PB4
04A8            304            ; The input pin used to check set to '1'
04A8 D295       305            setb P1.5
04AA            306            
04AA            307            ; Check if any push button is pressed
04AA C280       308            clr P0.0
04AC C281       309            clr P0.1
04AE C282       310            clr P0.2
04B0 C283       311            clr P0.3
04B2 C293       312            clr P1.3
04B4 209549     313            jb P1.5, LCD_PB_Done
04B7            314   
04B7            315            ; Debounce
04B7 7A32       316            mov R2, #50
04B9 120498     317            lcall waitms
04BC 209541     318            jb P1.5, LCD_PB_Done
04BF            319   
04BF            320            ; Set the LCD data pins to logic 1
04BF D280       321            setb P0.0
04C1 D281       322            setb P0.1
04C3 D282       323            setb P0.2
04C5 D283       324            setb P0.3
04C7 D293       325            setb P1.3
04C9            326            
04C9            327            ; Check the push buttons one by one
04C9 C293       328            clr P1.3
04CB A295       329            mov c, P1.5
04CD 9206       330            mov PB4, c
04CF D293       331            setb P1.3
04D1 300632     332            jnb PB4,increment_soak_temp
04D4            333   
04D4 C280       334            clr P0.0
04D6 A295       335            mov c, P1.5
04D8 9205       336            mov PB3, c
04DA D280       337            setb P0.0
04DC 300533     338            jnb PB3, increment_soak_time
04DF            339            
04DF C281       340            clr P0.1
04E1 A295       341            mov c, P1.5
04E3 9204       342            mov PB2, c
04E5 D281       343            setb P0.1
04E7 300434     344            jnb PB2, increment_reflow_temp
04EA            345            
04EA C282       346            clr P0.2
04EC A295       347            mov c, P1.5
04EE 9203       348            mov PB1, c
04F0 D282       349            setb P0.2
04F2 300335     350            jnb PB1, increment_reflow_time
04F5            351            
04F5 C283       352            clr P0.3
04F7 A295       353            mov c, P1.5
04F9 9202       354            mov PB0, c
04FB D283       355            setb P0.3
04FD 300236     356            jnb PB0, start_stop
0500            357   
0500            358   LCD_PB_Done:
0500 7A14       359            mov r2,#20
0502 120498     360            lcall waitms            
0505 22         361            ret
0506            362   
0506            363   increment_soak_temp:
0506 0545       364            inc soak_temp
0508 E545       365            mov a, soak_temp
050A B4F0F3     366            cjne a, #0xF0, LCD_PB_Done
050D 754500     367            mov soak_temp, #0x00
0510 80EE       368            sjmp LCD_PB_Done
0512            369   increment_soak_time:
0512 0544       370            inc soak_time
0514 E544       371            mov a, soak_time
0516 B478E7     372            cjne a, #0x78, LCD_PB_Done
0519 754400     373            mov soak_time, #0x00
051C 80E2       374            sjmp LCD_PB_Done
051E            375   increment_reflow_temp: 
051E 0543       376            inc reflow_temp
0520 E543       377            mov a, reflow_temp
0522 B4F0DB     378            cjne a, #0xF0, LCD_PB_Done
0525 754300     379            mov reflow_temp, #0x00
0528 80D6       380            sjmp LCD_PB_Done
052A            381   increment_reflow_time:
052A 0542       382            inc reflow_time
052C E542       383            mov a, reflow_time
052E B44BCF     384            cjne a, #0x4B, LCD_PB_Done
0531 754200     385            mov reflow_time, #0x00
0534 80CA       386            sjmp LCD_PB_Done
0536            387   
0536            388   start_stop:
0536 B208       389            cpl start_stop_flag
0538 80C6       390            sjmp LCD_PB_Done
053A            391   
053A            392   ; We can display a number any way we want.  In this case with
053A            393   ; four decimal places.
053A            394   Display_formated_BCD:
053A C0E0       395            push acc
053C 7404       395            mov a, #4
053E 14         395            dec a
053F 12012F     395            lcall ?Set_Cursor_1 ; Select column and row
0542 D0E0       395            pop acc ; display To
0544 C000       396            push ar0
0546 A83B       396            mov r0, bcd+3
0548 120134     396            lcall ?Display_BCD
054B D000       396            pop ar0
054D C000       397            push ar0
054F A83A       397            mov r0, bcd+2
0551 120134     397            lcall ?Display_BCD
0554 D000       397            pop ar0 ;this is just in case temperatures exceed 100C and we're in deg F
0556            398            
0556            399            ;send the BCD value to the MATLAB script
0556 C000       400            push ar0
0558 A83B       400            mov r0, bcd+3
055A 120152     400            lcall ?Send_BCD
055D D000       400            pop ar0
055F C000       401            push ar0
0561 A83A       401            mov r0, bcd+2
0563 120152     401            lcall ?Send_BCD
0566 D000       401            pop ar0
0568 C000       402            push ar0
056A A839       402            mov r0, bcd+1
056C 120152     402            lcall ?Send_BCD
056F D000       402            pop ar0
0571 740D       403            mov a, #'\r'
0573 12014A     404            lcall putchar
0576 740A       405            mov a, #'\n'
0578 12014A     406            lcall putchar
057B            407            ;Set_Cursor(1, 13)
057B            408            ;Send_Constant_String(#22) ; display Tj=22
057B            409            
057B C0E0       410            push acc
057D 740E       410            mov a, #14
057F 14         410            dec a
0580 12012D     410            lcall ?Set_Cursor_2 ; Select column and row
0583 D0E0       410            pop acc
0585 E53F       411            mov a,seconds
0587 12058B     412            lcall SendToLCD
058A            413            
058A 22         414            ret
058B            415   
058B            416   SendToLCD:
058B 75F064     417   mov b, #100
058E 84         418   div ab
058F 4430       419   orl a, #0x30 ; Convert hundreds to ASCII
0591 1200E5     420   lcall ?WriteData ; Send to LCD
0594 E5F0       421   mov a, b ; Remainder is in register b
0596 75F00A     422   mov b, #10
0599 84         423   div ab
059A 4430       424   orl a, #0x30 ; Convert tens to ASCII
059C 1200E5     425   lcall ?WriteData; Send to LCD
059F E5F0       426   mov a, b
05A1 4430       427   orl a, #0x30 ; Convert units to ASCII
05A3 1200E5     428   lcall ?WriteData; Send to LCD
05A6 22         429   ret
05A7            430   
05A7            431   ;-------------------------------------------------;
05A7            432   ; Display values from the pushbutton to the LCD   ;
05A7            433   ;-------------------------------------------------;
05A7            434   
05A7            435   Display_PushButtons_LCD:
05A7 C0E0       436            push acc
05A9 7402       436            mov a, #2
05AB 14         436            dec a
05AC 12012D     436            lcall ?Set_Cursor_2 ; Select column and row
05AF D0E0       436            pop acc
05B1 E545       437            mov a, soak_temp
05B3 12058B     438            lcall SendToLCD
05B6            439            
05B6 C0E0       440            push acc
05B8 7406       440            mov a, #6
05BA 14         440            dec a
05BB 12012D     440            lcall ?Set_Cursor_2 ; Select column and row
05BE D0E0       440            pop acc
05C0 E544       441            mov a, soak_time
05C2 12058B     442            lcall SendToLCD
05C5            443       
05C5 C0E0       444            push acc
05C7 740A       444            mov a, #10
05C9 14         444            dec a
05CA 12012D     444            lcall ?Set_Cursor_2 ; Select column and row
05CD D0E0       444            pop acc
05CF E543       445       mov a, reflow_temp
05D1 12058B     446            lcall SendToLCD
05D4            447       
05D4 C0E0       448            push acc
05D6 740E       448            mov a, #14
05D8 14         448            dec a
05D9 12012D     448            lcall ?Set_Cursor_2 ; Select column and row
05DC D0E0       448            pop acc
05DE E542       449       mov a, reflow_time
05E0 12058B     450            lcall SendToLCD
05E3            451            
05E3 22         452            ret
05E4            453   
05E4            454   
05E4            455   ;-------------------------------------------------;
05E4            456   ; Display all values and temperatures to the LCD  ;
05E4            457   ;-------------------------------------------------;
05E4            458   Display_Data:
05E4 C2EF       459            clr ADCF
05E6 D2EE       460            setb ADCS ;  ADC start trigger signal
05E8 30EFFD     461       jnb ADCF, $ ; Wait for conversion complete
05EB            462       
05EB            463       ; Read the ADC result and store in [R1, R0]
05EB E5C3       464       mov a, ADCRH   
05ED C4         465       swap a
05EE C0E0       466       push acc
05F0 540F       467       anl a, #0x0f
05F2 F9         468       mov R1, a
05F3 D0E0       469       pop acc
05F5 54F0       470       anl a, #0xf0
05F7 45C2       471       orl a, ADCRL
05F9 F8         472       mov R0, A
05FA            473       
05FA            474       ; Convert to voltage
05FA 8830       475            mov x+0, R0
05FC 8931       476            mov x+1, R1
05FE            477            ; Pad other bits with zero
05FE 753200     478            mov x+2, #0
0601 753300     479            mov x+3, #0
0604            480            
0604            481            ;lcall div32 ; Get V_out
0604            482            ; ; Calculate Temp based on V_out
0604            483            ; Load_y(27300) ; The reference temp K
0604            484            ; lcall sub32 ; Get Temp*0.01
0604            485            ; ; Change Temp*0.01 to Temp
0604            486            ; Load_y(100)
0604            487            ; lcall mul32
0604            488   
0604 75347C     489            mov y+0, #low (50300 % 0x10000) 
0607 7535C4     489            mov y+1, #high(50300 % 0x10000) 
060A 753600     489            mov y+2, #low (50300 / 0x10000) 
060D 753700     489            mov y+3, #high(50300 / 0x10000)  ; VCC voltage measured (equals 4.99V)
0610 1202E2     490            lcall mul32 ;multiplying ADC * Vref
0613 7534FF     491            mov y+0, #low (4095 % 0x10000) 
0616 75350F     491            mov y+1, #high(4095 % 0x10000) 
0619 753600     491            mov y+2, #low (4095 / 0x10000) 
061C 753700     491            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
061F 12036F     492            lcall div32 ;now doing (ADC*Vref)/(4095)
0622            493            
0622 7534E8     494            mov y+0, #low (1000 % 0x10000) 
0625 753503     494            mov y+1, #high(1000 % 0x10000) 
0628 753600     494            mov y+2, #low (1000 / 0x10000) 
062B 753700     494            mov y+3, #high(1000 / 0x10000)  ; for converting volt to microvolt
062E 1202E2     495            lcall mul32 ;multiplying volts
0631            496            
0631 75340A     497            mov y+0, #low (10 % 0x10000) 
0634 753500     497            mov y+1, #high(10 % 0x10000) 
0637 753600     497            mov y+2, #low (10 / 0x10000) 
063A 753700     497            mov y+3, #high(10 / 0x10000) 
063D 1202E2     498            lcall mul32
0640            499            
0640            500            ;convert to temperature
0640 7534D0     501            mov y+0, #low (21200 % 0x10000) 
0643 753552     501            mov y+1, #high(21200 % 0x10000) 
0646 753600     501            mov y+2, #low (21200 / 0x10000) 
0649 753700     501            mov y+3, #high(21200 / 0x10000)  ;divide by the gain 
064C 12036F     502            lcall div32 
064F 753429     503            mov y+0, #low (41 % 0x10000) 
0652 753500     503            mov y+1, #high(41 % 0x10000) 
0655 753600     503            mov y+2, #low (41 / 0x10000) 
0658 753700     503            mov y+3, #high(41 / 0x10000) ;load y = 41
065B 12036F     504            lcall div32 ;divide by 41
065E            505            
065E 753410     506            mov y+0, #low (10000 % 0x10000) 
0661 753527     506            mov y+1, #high(10000 % 0x10000) 
0664 753600     506            mov y+2, #low (10000 / 0x10000) 
0667 753700     506            mov y+3, #high(10000 / 0x10000) 
066A 1202E2     507            lcall mul32
066D            508            
066D 753460     509            mov y+0, #low (220000 % 0x10000) 
0670 75355B     509            mov y+1, #high(220000 % 0x10000) 
0673 753603     509            mov y+2, #low (220000 / 0x10000) 
0676 753700     509            mov y+3, #high(220000 / 0x10000)  ;cold junction 19 deg C
0679 12022D     510            lcall add32
067C            511   
067C            512   ; Convert to BCD and display
067C 120168     513            lcall hex2bcd
067F 12053A     514            lcall Display_formated_BCD
0682            515   
0682 32         516            reti
0683            517   
0683            518   ;-----------------------------------------------------------------------------;
0683            519   ;Grabs the value in register a and then compares it to the current temperature;
0683            520   ;-----------------------------------------------------------------------------;
0683            521   
0683            522   Display_temp:
0683 C2EF       523            clr ADCF
0685 D2EE       524            setb ADCS ;  ADC start trigger signal
0687 30EFFD     525       jnb ADCF, $ ; Wait for conversion complete
068A            526       
068A            527       ; Read the ADC result and store in [R1, R0]
068A E5C3       528       mov a, ADCRH   
068C C4         529       swap a
068D C0E0       530       push acc
068F 540F       531       anl a, #0x0f
0691 F9         532       mov R1, a
0692 D0E0       533       pop acc
0694 54F0       534       anl a, #0xf0
0696 45C2       535       orl a, ADCRL
0698 F8         536       mov R0, A
0699            537       
0699            538       ; Convert to voltage
0699 8830       539            mov x+0, R0
069B 8931       540            mov x+1, R1
069D            541            ; Pad other bits with zero
069D 753200     542            mov x+2, #0
06A0 753300     543            mov x+3, #0
06A3            544            
06A3            545            ;lcall div32 ; Get V_out
06A3            546            ; ; Calculate Temp based on V_out
06A3            547            ; Load_y(27300) ; The reference temp K
06A3            548            ; lcall sub32 ; Get Temp*0.01
06A3            549            ; ; Change Temp*0.01 to Temp
06A3            550            ; Load_y(100)
06A3            551            ; lcall mul32
06A3            552   
06A3 75347C     553            mov y+0, #low (50300 % 0x10000) 
06A6 7535C4     553            mov y+1, #high(50300 % 0x10000) 
06A9 753600     553            mov y+2, #low (50300 / 0x10000) 
06AC 753700     553            mov y+3, #high(50300 / 0x10000)  ; VCC voltage measured (equals 4.99V)
06AF 1202E2     554            lcall mul32 ;multiplying ADC * Vref
06B2 7534FF     555            mov y+0, #low (4095 % 0x10000) 
06B5 75350F     555            mov y+1, #high(4095 % 0x10000) 
06B8 753600     555            mov y+2, #low (4095 / 0x10000) 
06BB 753700     555            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
06BE 12036F     556            lcall div32 ;now doing (ADC*Vref)/(4095)
06C1            557            
06C1 7534E8     558            mov y+0, #low (1000 % 0x10000) 
06C4 753503     558            mov y+1, #high(1000 % 0x10000) 
06C7 753600     558            mov y+2, #low (1000 / 0x10000) 
06CA 753700     558            mov y+3, #high(1000 / 0x10000)  ; for converting volt to microvolt
06CD 1202E2     559            lcall mul32 ;multiplying volts
06D0            560            
06D0 75340A     561            mov y+0, #low (10 % 0x10000) 
06D3 753500     561            mov y+1, #high(10 % 0x10000) 
06D6 753600     561            mov y+2, #low (10 / 0x10000) 
06D9 753700     561            mov y+3, #high(10 / 0x10000) 
06DC 1202E2     562            lcall mul32
06DF            563            
06DF            564            ;convert to temperature
06DF 7534D0     565            mov y+0, #low (21200 % 0x10000) 
06E2 753552     565            mov y+1, #high(21200 % 0x10000) 
06E5 753600     565            mov y+2, #low (21200 / 0x10000) 
06E8 753700     565            mov y+3, #high(21200 / 0x10000)  ;divide by the gain 
06EB 12036F     566            lcall div32 
06EE 753429     567            mov y+0, #low (41 % 0x10000) 
06F1 753500     567            mov y+1, #high(41 % 0x10000) 
06F4 753600     567            mov y+2, #low (41 / 0x10000) 
06F7 753700     567            mov y+3, #high(41 / 0x10000) ;load y = 41
06FA 12036F     568            lcall div32 ;divide by 41
06FD            569            
06FD 753410     570            mov y+0, #low (10000 % 0x10000) 
0700 753527     570            mov y+1, #high(10000 % 0x10000) 
0703 753600     570            mov y+2, #low (10000 / 0x10000) 
0706 753700     570            mov y+3, #high(10000 / 0x10000) 
0709 1202E2     571            lcall mul32
070C            572            
070C 753460     573            mov y+0, #low (220000 % 0x10000) 
070F 75355B     573            mov y+1, #high(220000 % 0x10000) 
0712 753603     573            mov y+2, #low (220000 / 0x10000) 
0715 753700     573            mov y+3, #high(220000 / 0x10000)  ;cold junction 19 deg C
0718 12022D     574            lcall add32
071B            575   
071B            576   ; Convert to BCD and display
071B 120168     577            lcall hex2bcd
071E 120722     578            lcall Display_temperature
0721            579   
0721 32         580            reti
0722            581   
0722            582   Display_temperature:
0722 C0E0       583            push acc
0724 7404       583            mov a, #4
0726 14         583            dec a
0727 12012F     583            lcall ?Set_Cursor_1 ; Select column and row
072A D0E0       583            pop acc ; display To
072C C000       584            push ar0
072E A83B       584            mov r0, bcd+3
0730 120134     584            lcall ?Display_BCD
0733 D000       584            pop ar0
0735 C000       585            push ar0
0737 A83A       585            mov r0, bcd+2
0739 120134     585            lcall ?Display_BCD
073C D000       585            pop ar0 ;this is just in case temperatures exceed 100C and we're in deg F
073E 32         586            reti
073F            587   
073F            588   Compare_temp:
073F 853A48     589            mov temp+0, bcd+2
0742 853B49     590            mov temp+1, bcd+3
0745 854838     591            mov bcd+0, temp+0
0748 854939     592            mov bcd+1, temp+1
074B 753A00     593            mov bcd+2,#0
074E 753B00     594            mov bcd+3,#0
0751 753C00     595            mov bcd+4,#0
0754            596            
0754 1201F1     597            lcall bcd2hex
0757            598            
0757 853034     599            mov y+0,x+0
075A 853135     600            mov y+1,x+1
075D 853236     601            mov y+2,x+2
0760 853337     602            mov y+3,x+3
0763            603            
0763 F530       604            mov x+0,a
0765 753100     605            mov x+1,#0
0768 753200     606            mov x+2,#0
076B 753300     607            mov x+3,#0
076E            608            
076E 120168     609            lcall hex2bcd
0771 1202D8     610            lcall x_lteq_y
0774            611   
0774 32         612            reti
0775            613   
0775            614   Wait_1sec:
0775            615            ; Wait 500 ms between conversions
0775 7AFA       616            mov R2, #250
0777 120498     617            lcall waitms
077A 7AFA       618            mov R2, #250
077C 120498     619            lcall waitms
077F            620            ; Wait 500 ms between conversions
077F 7AFA       621            mov R2, #250
0781 120498     622            lcall waitms
0784 7AFA       623            mov R2, #250
0786 120498     624            lcall waitms
0789 32         625            reti
078A            626   
078A            627   main:
078A 75817F     628            mov sp, #0x7f
078D 12043E     629            lcall Init_All
0790 1200EF     630       lcall LCD_4BIT
0793 1203D8     631       lcall Timer0_Init
0796 1203FB     632       lcall Timer2_Init
0799 D2AF       633       setb EA   ; Enable Global interrupts
079B            634       ; initial messages in LCD
079B C0E0       635            push acc
079D 7401       635            mov a, #1
079F 14         635            dec a
07A0 12012F     635            lcall ?Set_Cursor_1 ; Select column and row
07A3 D0E0       635            pop acc
07A5 C083       636            push dph
07A7 C082       636            push dpl
07A9 C0E0       636            push acc
07AB 90002E     636            mov dptr, #To_Message
07AE 120122     636            lcall ?Send_Constant_String
07B1 D0E0       636            pop acc
07B3 D082       636            pop dpl
07B5 D083       636            pop dph
07B7 C0E0       637            push acc
07B9 7401       637            mov a, #1
07BB 14         637            dec a
07BC 12012D     637            lcall ?Set_Cursor_2 ; Select column and row
07BF D0E0       637            pop acc
07C1 C083       638            push dph
07C3 C082       638            push dpl
07C5 C0E0       638            push acc
07C7 90003F     638            mov dptr, #Time_temp_display
07CA 120122     638            lcall ?Send_Constant_String
07CD D0E0       638            pop acc
07CF D082       638            pop dpl
07D1 D083       638            pop dph
07D3 754B00     639       mov FSM_state,#0
07D6 753F00     640            mov seconds, #0x00
07D9 75458C     641            mov soak_temp, #0x8C ;140
07DC 75443C     642            mov soak_time, #0x3C ; 60
07DF 7543E6     643            mov reflow_temp, #0xE6 ; 230
07E2 75421E     644            mov reflow_time, #0x1E ; 30
07E5 753800     645            mov bcd,#0
07E8            646            
07E8 C208       647            clr start_stop_flag
07EA C207       648            clr FSM_start_flag
07EC            649       
07EC            650   ;---------------------------------;
07EC            651   ;                FSM     funtion                               ;
07EC            652   ;---------------------------------;
07EC            653   FSM:
07EC E54B       654       mov a, FSM_state
07EE            655   FSM_state0: ;initial state
07EE B40036     656       cjne a, #0, FSM_state1
07F1 754700     657       mov pwm, #0 ; power variable
07F4 12049E     658            lcall LCD_PB ; calls and checks the pushbuttons
07F7 1205A7     659            lcall Display_PushButtons_LCD ;Displays values in pushbuttons
07FA 120683     660            lcall Display_temp
07FD 300824     661       jnb start_stop_flag, FSM_state0_done
0800 D207       662       setb FSM_start_flag
0802 753F00     663       mov seconds, #0x00     ; set time to 0
0805 754B01     664       mov FSM_state, #1   ; set FSM_state to 1, next state is state1
0808 C0E0       665            push acc
080A 7401       665            mov a, #1
080C 14         665            dec a
080D 12012D     665            lcall ?Set_Cursor_2 ; Select column and row
0810 D0E0       665            pop acc
0812 C083       666            push dph
0814 C082       666            push dpl
0816 C0E0       666            push acc
0818 900050     666            mov dptr, #Ramp_to_soak
081B 120122     666            lcall ?Send_Constant_String
081E D0E0       666            pop acc
0820 D082       666            pop dpl
0822 D083       666            pop dph
0824            667   FSM_state0_done:
0824 0207EC     668       ljmp FSM   ;jump back to FSM and reload FSM_state to a
0827            669   
0827            670   FSM_state1: ;ramp to soak
0827 B40147     671       cjne a, #1, FSM_state2
082A 754764     672       mov pwm, #100
082D C3         673       clr c
082E 300834     674       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
0831 743C       675       mov a, #0x3C
0833 953F       676       subb a, seconds
0835 401A       677       jc abort
0837            678   continue:
0837 C3         679       clr c   ; ! i don't know what is c
0838 300113     680            jnb s_flag, FSM_state1_done
083B C201       681            clr s_flag
083D 1205E4     682            lcall Display_Data
0840 E545       683            mov a, soak_temp    ; set a to soak temp
0842 12073F     684            lcall Compare_temp
0845 300006     685       jnb mf, FSM_state1_done
0848 753F00     686       mov seconds, #0x00     ; set time to 0
084B 754B02     687       mov FSM_state, #2
084E            688   FSM_state1_done:
084E 0207EC     689       ljmp FSM
0851            690   abort:
0851 7432       691       mov a, #0x32  ; set a to 50 degree
0853 3001F8     692            jnb s_flag, FSM_state1_done
0856 1205E4     693            lcall Display_Data
0859 12073F     694            lcall Compare_temp
085C 2000D8     695            jb mf, continue ; if temp is larger then 50 degree, go back to continue
085F 754B00     696       mov FSM_state, #0   ; abort the FSM
0862 02078A     697            ljmp main
0865            698   
0865            699   stop_state:
0865 C2CA       700       clr TR2
0867 300805     701       jnb start_stop_flag, stop
086A D2CA       702            setb TR2
086C 0207EC     703            ljmp FSM
086F            704   
086F            705   stop:
086F 80F4       706       sjmp stop_state
0871            707   
0871            708   FSM_state2: ;preheat/soak
0871 B4023A     709       cjne a, #2, FSM_state3
0874 754714     710       mov pwm, #20
0877 C0E0       711            push acc
0879 7401       711            mov a, #1
087B 14         711            dec a
087C 12012D     711            lcall ?Set_Cursor_2 ; Select column and row
087F D0E0       711            pop acc
0881 C083       712            push dph
0883 C082       712            push dpl
0885 C0E0       712            push acc
0887 90005E     712            mov dptr, #Soak_display
088A 120122     712            lcall ?Send_Constant_String
088D D0E0       712            pop acc
088F D082       712            pop dpl
0891 D083       712            pop dph
0893 C3         713       clr c   ; ! i don't know what is c 
0894 300114     714            jnb s_flag, FSM_state2_done
0897 C201       715            clr s_flag
0899 1205E4     716            lcall Display_Data
089C 3008C6     717       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
089F E544       718            mov a, soak_time    ; set a to soak time
08A1 953F       719       subb a, seconds    ; temp is our currect sec
08A3 5006       720       jnc FSM_state2_done
08A5 753F00     721       mov seconds, #0x00     ; set time to 0
08A8 754B03     722       mov FSM_state, #3
08AB            723   FSM_state2_done:
08AB 0207EC     724       ljmp FSM
08AE            725   
08AE            726   FSM_state3: ;ramp to peak
08AE B40342     727       cjne a, #3, FSM_state4
08B1 754764     728       mov pwm, #100
08B4 C0E0       729            push acc
08B6 7401       729            mov a, #1
08B8 14         729            dec a
08B9 12012D     729            lcall ?Set_Cursor_2 ; Select column and row
08BC D0E0       729            pop acc
08BE C083       730            push dph
08C0 C082       730            push dpl
08C2 C0E0       730            push acc
08C4 90006C     730            mov dptr, #Ramp_to_peak
08C7 120122     730            lcall ?Send_Constant_String
08CA D0E0       730            pop acc
08CC D082       730            pop dpl
08CE D083       730            pop dph
08D0 C3         731       clr c   ; ! i don't know what is c 
08D1 300891     732       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
08D4 300113     733            jnb s_flag, FSM_state3_done
08D7 C201       734            clr s_flag
08D9 1205E4     735            lcall Display_Data
08DC E543       736            mov a, reflow_temp    ; set a to reflow temp
08DE 12073F     737            lcall Compare_temp
08E1 300006     738       jnb mf, FSM_state3_done
08E4 753F00     739       mov seconds, #0x00     ; set time to 0
08E7 754B04     740       mov FSM_state, #4
08EA            741   FSM_state3_done:
08EA 0207EC     742       ljmp FSM
08ED            743            
08ED            744   intermediate_state_0:
08ED 0207EC     745            ljmp FSM
08F0            746   
08F0            747   intermediate_stop_jump:
08F0 020865     748            ljmp stop_state
08F3            749   
08F3            750   FSM_state4:;reflow
08F3 B4043A     751       cjne a, #4, FSM_state5
08F6 754714     752       mov pwm, #20
08F9 C0E0       753            push acc
08FB 7401       753            mov a, #1
08FD 14         753            dec a
08FE 12012D     753            lcall ?Set_Cursor_2 ; Select column and row
0901 D0E0       753            pop acc
0903 C083       754            push dph
0905 C082       754            push dpl
0907 C0E0       754            push acc
0909 90007A     754            mov dptr, #Reflow_display
090C 120122     754            lcall ?Send_Constant_String
090F D0E0       754            pop acc
0911 D082       754            pop dpl
0913 D083       754            pop dph
0915 C3         755       clr c   ; ! i don't know what is c 
0916 300114     756            jnb s_flag, FSM_state4_done
0919 C201       757            clr s_flag
091B 1205E4     758            lcall Display_Data
091E 3008CF     759       jnb start_stop_flag, intermediate_stop_jump; checks the flag if 0, then means stop was pressed, if 1 keep on going
0921 E542       760            mov a, reflow_time    ; set a to reflow time
0923 953F       761       subb a, seconds    ; temp is our currect sec
0925 5006       762       jnc FSM_state4_done
0927 753F00     763       mov seconds, #0x00     ; set time to 0
092A 754B05     764       mov FSM_state, #5
092D            765   FSM_state4_done:
092D 0207EC     766       ljmp FSM
0930            767   
0930            768   FSM_state5:;cooling
0930 B405BA     769       cjne a, #5, intermediate_state_0
0933 754700     770       mov pwm, #0
0936            771       
0936 C0E0       772            push acc
0938 7401       772            mov a, #1
093A 14         772            dec a
093B 12012D     772            lcall ?Set_Cursor_2 ; Select column and row
093E D0E0       772            pop acc
0940 C083       773            push dph
0942 C082       773            push dpl
0944 C0E0       773            push acc
0946 900088     773            mov dptr, #Cooling_display
0949 120122     773            lcall ?Send_Constant_String
094C D0E0       773            pop acc
094E D082       773            pop dpl
0950 D083       773            pop dph
0952 C3         774       clr c
0953 30089A     775       jnb start_stop_flag, intermediate_stop_jump ; checks the flag if 0, then means stop was pressed, if 1 keep on going 
0956 300116     776            jnb s_flag, FSM_state5_done
0959 C201       777            clr s_flag
095B 1205E4     778            lcall Display_Data
095E 743C       779            mov a, #0x3C    ; set a to 60
0960 12073F     780            lcall Compare_temp
0963            781   
0963 200009     782       jb mf, FSM_state5_done
0966 753F00     783       mov seconds, #0x00     ; set time to 0
0969 754B00     784       mov FSM_state, #0
096C 02078A     785            ljmp main
096F            786   FSM_state5_done:
096F 0207EC     787       ljmp FSM
0972            788   EN
