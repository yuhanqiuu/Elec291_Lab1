                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             21   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             22   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             23   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER1_RELOAD     EQU (0x100-(CLK/(BAUD)))
0000             25   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             26   TIMER2_RATE   EQU 100     ; 100Hz, for a timer tick of 1s
0000             27   TIMER2_RELOAD EQU ((65536-(CLK/(16*TIMER2_RATE))))
0000             28   
0000             29   ;---------------------------------;
0000             30   ; Define any buttons & pins here  ;
0000             31   ;---------------------------------;
0000             32   SOUND_OUT   equ p1.7 ; speaker pin
0000             33   PWM_OUT    EQU P1.0 ; Logic 1 = oven on
0000             34   ;---------------------------------------------
0000             35   
0000             36   ORG 0x0000
0000 0206D7      37            ljmp main
0003             38   
0003             39   ; External interrupt 0 vector (not used in this code)
0003             40   org 0x0003
0003 32          41            reti
0004             42   
0004             43   ; Timer/Counter 0 overflow interrupt vector
000B             44   org 0x000B
000B 0203F7      45            ljmp Timer0_ISR
000E             46   
000E             47   ; External interrupt 1 vector (not used in this code)
0013             48   org 0x0013
0013 32          49            reti
0014             50   
0014             51   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             52   org 0x001B
001B 32          53            reti
001C             54   
001C             55   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             56   org 0x0023 
0023 32          57            reti
0024             58            
0024             59   ; Timer/Counter 2 overflow interrupt vector
002B             60   org 0x002B
002B 020424      61            ljmp Timer2_ISR
002E             62   
002E             63   ;---------------------------------;
002E             64   ; Define any constant string here ;
002E             65   ;---------------------------------;
002E             66   ;                          1234567890123456    <- This helps determine the location of the counter
002E 546F3D78    67   To_Message:        db 'To=xxxC Tj= 22C ', 0
     78784320
     546A3D20
     32324320
     00
003F 73787878    68   Time_temp_display:db 'sxxx,xx rxxx,xx ', 0 ; soak temp,time reflow temp,time
     2C787820
     72787878
     2C787820
     00
0050 52616D70    69   Ramp_to_soak:      db 'RampToSoak s=xxx', 0 ; state 1 display
     546F536F
     616B2073
     3D787878
     00
0061 536F616B    70   Soak_display:      db 'Soak               s=xxx', 0 ; state 2 display
     20090920
     733D7878
     7800
006F 52616D70    71   Ramp_to_peak:      db 'RampToPeak s=xxx', 0 ; state 3 display
     546F5065
     616B2073
     3D787878
     00
0080 5265666C    72   Reflow_display:   db 'Reflow      s=xxx', 0 ; state 4 display
     6F772009
     20733D78
     787800
008F 436F6F6C    73   Cooling_display:  db 'Cooling     s=xxx', 0 ; state 5 display
     696E6720
     0920733D
     78787800
009F             74   ;---------------------------------------------
009F             75   cseg
009F             76   
009F             77   LCD_RS equ P1.3
009F             78   LCD_E  equ P1.4
009F             79   LCD_D4 equ P0.0
009F             80   LCD_D5 equ P0.1
009F             81   LCD_D6 equ P0.2
009F             82   LCD_D7 equ P0.3
009F             83   
                 85   $LIST
0171             87   
0171             88   ;---------------------------------;
0171             89   ; Define variables here           ;
0171             90   ;---------------------------------;
0171             91   ; These register definitions needed by 'math32.inc'
0030             92   DSEG at 30H
0030             93   x:   ds 4
0034             94   y:   ds 4
0038             95   bcd: ds 5   ;temperature variable for reading
003D             96   Count1ms:     ds 2 ; Used to determine when one second has passed
003F             97   seconds: ds 1
0040             98   VLED_ADC: ds 2
0042             99   reflow_time: ds 1 ; time parameter for reflow    
0043            100   reflow_temp: ds 1 ; temp parameter for reflow
0044            101   soak_time: ds 1 ; time parameter for soak
0045            102   soak_temp: ds 1 ; temp parameter for soak
0046            103   pwm_counter: ds 1 ; power counter
0047            104   pwm: ds 1 ; variable to count the power percentage
0048            105   temp: ds 3
004B            106   FSM_state: ds 1
004C            107   ;---------------------------------------------
004C            108   
004C            109   ;---------------------------------;
004C            110   ; Define flags here               ;
004C            111   ;---------------------------------;
0000            112   BSEG
0000            113   mf: dbit 1
0001            114   s_flag: dbit 1 ; Set to one in the ISR every time 1000 ms had passed
0002            115   PB0: dbit 1      ; start/stop
0003            116   PB1: dbit 1      ; increment reflow time
0004            117   PB2: dbit 1      ; increment reflow temp
0005            118   PB3: dbit 1      ; increment soak time
0006            119   PB4: dbit 1      ; increment soak temp
0007            120   FSM_start_flag: dbit 1 ; once it starts the timer2 will start checking for stop pushbutton
0008            121   start_stop_flag: dbit 1 ; Set to one if button is pressed to start, press again to stop
0009            122   ;---------------------------------------------
0009            123   
                546   $LIST
                125   $LIST
03E1            127   
03E1            128   ;---------------------------------;
03E1            129   ; Routine to initialize the ISR   ;
03E1            130   ; for timer 0                     ;
03E1            131   ;---------------------------------;
03E1            132   Timer0_Init:
03E1 438E08     133            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
03E4 E589       134            mov a, TMOD
03E6 54F0       135            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03E8 4401       136            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03EA F589       137            mov TMOD, a
03EC 758CF0     138            mov TH0, #high(TIMER0_RELOAD)
03EF 758A2C     139            mov TL0, #low(TIMER0_RELOAD)
03F2            140            ; Enable the timer and interrupts
03F2 D2A9       141       setb ET0  ; Enable timer 0 interrupt
03F4 D28C       142       setb TR0  ; Start timer 0
03F6 22         143            ret
03F7            144   
03F7            145   ;---------------------------------;
03F7            146   ; ISR for timer 0.  Set to execute;
03F7            147   ; every 1/4096Hz to generate a    ;
03F7            148   ; 2048 Hz wave at pin SOUND_OUT   ;
03F7            149   ;---------------------------------;
03F7            150   Timer0_ISR:
03F7            151            ;clr TF0  ; According to the data sheet this is done for us already.
03F7            152            ; Timer 0 doesn't have 16-bit auto-reload, so
03F7 C28C       153            clr TR0
03F9 758CF0     154            mov TH0, #high(TIMER0_RELOAD)
03FC 758A2C     155            mov TL0, #low(TIMER0_RELOAD)
03FF D28C       156            setb TR0
0401 B297       157            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0403 32         158            reti
0404            159   
0404            160   ;---------------------------------;
0404            161   ; Routine to initialize the ISR   ;
0404            162   ; for timer 2                     ;
0404            163   ;---------------------------------;
0404            164   Timer2_Init:
0404 75C800     165            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0407 75CDD7     166            mov TH2, #high(TIMER2_RELOAD)
040A 75CC79     167            mov TL2, #low(TIMER2_RELOAD)
040D            168            ; Set the reload value
040D 75C9A0     169            mov T2MOD, #0b1010_0000 ; Enable timer 2 autoreload, and clock divider is 16
0410 75CBD7     170            mov RCMP2H, #high(TIMER2_RELOAD)
0413 75CA79     171            mov RCMP2L, #low(TIMER2_RELOAD)
0416            172            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0416 E4         173            clr a
0417 F53D       174            mov Count1ms+0, a
0419 F53E       175            mov Count1ms+1, a
041B 754700     176            mov pwm, #0
041E            177            ; Enable the timer and interrupts
041E 439B80     178            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0421 D2CA       179       setb TR2  ; Enable timer 2
0423 22         180            ret
0424            181   
0424            182   ;---------------------------------;
0424            183   ; ISR for timer 2 ;
0424            184   ;---------------------------------;
0424            185   Timer2_ISR:
0424 C2CF       186            clr TF2 ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR. It is bit addressable.
0426 B284       187            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0428            188                    
0428            189            ; The two registers used in the ISR must be saved in the stack
0428 C0D0       190            push psw
042A C0E0       191            push acc
042C 0546       192            inc pwm_counter
042E C3         193            clr c
042F E547       194            mov a, pwm
0431 9546       195            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0433 B3         196            cpl c
0434 9290       197            mov PWM_OUT, c
0436 E546       198            mov a, pwm_counter
0438            199   
0438 B46407     200            cjne a, #100, Timer2_ISR_done
043B 754600     201            mov pwm_counter, #0
043E 053F       202            inc seconds
0440 D201       203            setb s_flag
0442            204            
0442            205            
0442            206            
0442            207   ;        jb FSM_start_flag, check_stop
0442            208            
0442            209   Timer2_ISR_done:
0442            210   
0442 D0E0       211            pop acc
0444 D0D0       212            pop psw
0446 32         213            reti
0447            214   
0447            215   ; check_stop:
0447            216   ;        setb PB4
0447            217   ;        ; The input pin used to check set to '1'
0447            218   ;        setb P1.5
0447            219   ;        clr P0.3
0447            220   ;        jb P1.5, stop_PB_Done
0447            221   ;        ; Debounce
0447            222   ;        mov R2, #50
0447            223   ;        lcall waitms
0447            224   ;        jb P1.5, stop_PB_Done
0447            225   ;        setb P0.3
0447            226   ;        clr P0.3
0447            227   ;        mov c, P1.5
0447            228   ;        mov PB0, c
0447            229   ;        setb P0.3
0447            230   ;        jnb PB0, start_stop_timer
0447            231            
0447            232   ; stop_PB_Done:
0447            233   ;        ljmp Timer2_ISR_done
0447            234   ; start_stop_timer:
0447            235   ;        cpl start_stop_flag
0447            236   ;        sjmp stop_PB_Done
0447            237   
0447            238   ;---------------------------------;
0447            239   ; Temperature senseor function    ;
0447            240   ;---------------------------------;
0447            241   Init_All:
0447            242            ; Configure all the pins for biderectional I/O
0447 75AC00     243            mov     P3M1, #0x00
044A 75AD00     244            mov     P3M2, #0x00
044D 75B300     245            mov     P1M1, #0x00
0450 75B400     246            mov     P1M2, #0x00
0453 75B100     247            mov     P0M1, #0x00
0456 75B200     248            mov     P0M2, #0x00
0459            249            
0459 438E10     250            orl     CKCON, #0x10 ; CLK is the input for timer 1
045C 438780     251            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
045F 759852     252            mov     SCON, #0x52
0462 53C4DF     253            anl     T3CON, #0b11011111
0465 53890F     254            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0468 438920     255            orl     TMOD, #0x20 ; Timer 1 Mode 2
046B 758D70     256            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
046E D28E       257            setb TR1
0470            258            
0470            259            ; Using timer 0 for delay functions.  Initialize here:
0470 C28C       260            clr     TR0 ; Stop timer 0
0472 438E08     261            orl     CKCON,#0x08 ; CLK is the input for timer 0
0475 5389F0     262            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0478 438901     263            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
047B            264            
047B            265            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
047B 43B382     266            orl     P1M1, #0b10000010
047E 53B47D     267            anl     P1M2, #0b01111101
0481            268            
0481            269            ; Initialize and start the ADC:
0481 53E8F0     270            anl ADCCON0, #0xF0
0484 43E807     271            orl ADCCON0, #0x07 ; Select channel 7
0487            272            ; AINDIDS select if some pins are analog inputs or digital I/O:
0487 75F600     273            mov AINDIDS, #0x00 ; Disable all analog inputs
048A 43F681     274            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
048D 43E101     275            orl ADCCON1, #0x01 ; Enable ADC
0490            276            
0490 22         277            ret
0491            278   
0491            279   wait_1ms:
0491 C28C       280            clr     TR0 ; Stop timer 0
0493 C28D       281            clr     TF0 ; Clear overflow flag
0495 758CBF     282            mov     TH0, #high(TIMER0_RELOAD_1MS)
0498 758A28     283            mov     TL0,#low(TIMER0_RELOAD_1MS)
049B D28C       284            setb TR0
049D 308DFD     285            jnb     TF0, $ ; Wait for overflow
04A0 22         286            ret
04A1            287   
04A1            288   ; Wait the number of miliseconds in R2
04A1            289   waitms:
04A1 120491     290            lcall wait_1ms
04A4 DAFB       291            djnz R2, waitms
04A6 22         292            ret
04A7            293   
04A7            294   ;---------------------------------;
04A7            295   ;         5_pushbuttons function               ;
04A7            296   ;---------------------------------;
04A7            297   LCD_PB:
04A7            298            ; Set variables to 1: 'no push button pressed'
04A7 D202       299            setb PB0
04A9 D203       300            setb PB1
04AB D204       301            setb PB2
04AD D205       302            setb PB3
04AF D206       303            setb PB4
04B1            304            ; The input pin used to check set to '1'
04B1 D295       305            setb P1.5
04B3            306            
04B3            307            ; Check if any push button is pressed
04B3 C280       308            clr P0.0
04B5 C281       309            clr P0.1
04B7 C282       310            clr P0.2
04B9 C283       311            clr P0.3
04BB C293       312            clr P1.3
04BD 209549     313            jb P1.5, LCD_PB_Done
04C0            314   
04C0            315            ; Debounce
04C0 7A32       316            mov R2, #50
04C2 1204A1     317            lcall waitms
04C5 209541     318            jb P1.5, LCD_PB_Done
04C8            319   
04C8            320            ; Set the LCD data pins to logic 1
04C8 D280       321            setb P0.0
04CA D281       322            setb P0.1
04CC D282       323            setb P0.2
04CE D283       324            setb P0.3
04D0 D293       325            setb P1.3
04D2            326            
04D2            327            ; Check the push buttons one by one
04D2 C293       328            clr P1.3
04D4 A295       329            mov c, P1.5
04D6 9206       330            mov PB4, c
04D8 D293       331            setb P1.3
04DA 300632     332            jnb PB4,increment_soak_temp
04DD            333   
04DD C280       334            clr P0.0
04DF A295       335            mov c, P1.5
04E1 9205       336            mov PB3, c
04E3 D280       337            setb P0.0
04E5 300533     338            jnb PB3, increment_soak_time
04E8            339            
04E8 C281       340            clr P0.1
04EA A295       341            mov c, P1.5
04EC 9204       342            mov PB2, c
04EE D281       343            setb P0.1
04F0 300434     344            jnb PB2, increment_reflow_temp
04F3            345            
04F3 C282       346            clr P0.2
04F5 A295       347            mov c, P1.5
04F7 9203       348            mov PB1, c
04F9 D282       349            setb P0.2
04FB 300335     350            jnb PB1, increment_reflow_time
04FE            351            
04FE C283       352            clr P0.3
0500 A295       353            mov c, P1.5
0502 9202       354            mov PB0, c
0504 D283       355            setb P0.3
0506 300236     356            jnb PB0, start_stop
0509            357   
0509            358   LCD_PB_Done:
0509 7A14       359            mov r2,#20
050B 1204A1     360            lcall waitms            
050E 22         361            ret
050F            362   
050F            363   increment_soak_temp:
050F 0545       364            inc soak_temp
0511 E545       365            mov a, soak_temp
0513 B4F0F3     366            cjne a, #0xF0, LCD_PB_Done
0516 754500     367            mov soak_temp, #0x00
0519 80EE       368            sjmp LCD_PB_Done
051B            369   increment_soak_time:
051B 0544       370            inc soak_time
051D E544       371            mov a, soak_time
051F B478E7     372            cjne a, #0x78, LCD_PB_Done
0522 754400     373            mov soak_time, #0x00
0525 80E2       374            sjmp LCD_PB_Done
0527            375   increment_reflow_temp: 
0527 0543       376            inc reflow_temp
0529 E543       377            mov a, reflow_temp
052B B4F0DB     378            cjne a, #0xF0, LCD_PB_Done
052E 754300     379            mov reflow_temp, #0x00
0531 80D6       380            sjmp LCD_PB_Done
0533            381   increment_reflow_time:
0533 0542       382            inc reflow_time
0535 E542       383            mov a, reflow_time
0537 B44BCF     384            cjne a, #0x4B, LCD_PB_Done
053A 754200     385            mov reflow_time, #0x00
053D 80CA       386            sjmp LCD_PB_Done
053F            387   
053F            388   start_stop:
053F B208       389            cpl start_stop_flag
0541 80C6       390            sjmp LCD_PB_Done
0543            391   
0543            392   ; We can display a number any way we want.  In this case with
0543            393   ; four decimal places.
0543            394   Display_formated_BCD:
0543 C0E0       395            push acc
0545 7404       395            mov a, #4
0547 14         395            dec a
0548 120138     395            lcall ?Set_Cursor_1 ; Select column and row
054B D0E0       395            pop acc ; display To
054D C000       396            push ar0
054F A83B       396            mov r0, bcd+3
0551 12013D     396            lcall ?Display_BCD
0554 D000       396            pop ar0
0556 C000       397            push ar0
0558 A83A       397            mov r0, bcd+2
055A 12013D     397            lcall ?Display_BCD
055D D000       397            pop ar0 ;this is just in case temperatures exceed 100C and we're in deg F
055F            398            
055F            399            ;send the BCD value to the MATLAB script
055F C000       400            push ar0
0561 A83B       400            mov r0, bcd+3
0563 12015B     400            lcall ?Send_BCD
0566 D000       400            pop ar0
0568 C000       401            push ar0
056A A83A       401            mov r0, bcd+2
056C 12015B     401            lcall ?Send_BCD
056F D000       401            pop ar0
0571 C000       402            push ar0
0573 A839       402            mov r0, bcd+1
0575 12015B     402            lcall ?Send_BCD
0578 D000       402            pop ar0
057A 740D       403            mov a, #'\r'
057C 120153     404            lcall putchar
057F 740A       405            mov a, #'\n'
0581 120153     406            lcall putchar
0584            407            ;Set_Cursor(1, 13)
0584            408            ;Send_Constant_String(#22) ; display Tj=22
0584            409            
0584 C0E0       410            push acc
0586 740E       410            mov a, #14
0588 14         410            dec a
0589 120136     410            lcall ?Set_Cursor_2 ; Select column and row
058C D0E0       410            pop acc
058E E53F       411            mov a,seconds
0590 120594     412            lcall SendToLCD
0593            413            
0593 22         414            ret
0594            415   
0594            416   SendToLCD:
0594 75F064     417   mov b, #100
0597 84         418   div ab
0598 4430       419   orl a, #0x30 ; Convert hundreds to ASCII
059A 1200EE     420   lcall ?WriteData ; Send to LCD
059D E5F0       421   mov a, b ; Remainder is in register b
059F 75F00A     422   mov b, #10
05A2 84         423   div ab
05A3 4430       424   orl a, #0x30 ; Convert tens to ASCII
05A5 1200EE     425   lcall ?WriteData; Send to LCD
05A8 E5F0       426   mov a, b
05AA 4430       427   orl a, #0x30 ; Convert units to ASCII
05AC 1200EE     428   lcall ?WriteData; Send to LCD
05AF 22         429   ret
05B0            430   
05B0            431   ;-------------------------------------------------;
05B0            432   ; Display values from the pushbutton to the LCD   ;
05B0            433   ;-------------------------------------------------;
05B0            434   
05B0            435   Display_PushButtons_LCD:
05B0 C0E0       436            push acc
05B2 7402       436            mov a, #2
05B4 14         436            dec a
05B5 120136     436            lcall ?Set_Cursor_2 ; Select column and row
05B8 D0E0       436            pop acc
05BA E545       437            mov a, soak_temp
05BC 120594     438            lcall SendToLCD
05BF            439            
05BF C0E0       440            push acc
05C1 7406       440            mov a, #6
05C3 14         440            dec a
05C4 120136     440            lcall ?Set_Cursor_2 ; Select column and row
05C7 D0E0       440            pop acc
05C9 E544       441            mov a, soak_time
05CB 120594     442            lcall SendToLCD
05CE            443       
05CE C0E0       444            push acc
05D0 740A       444            mov a, #10
05D2 14         444            dec a
05D3 120136     444            lcall ?Set_Cursor_2 ; Select column and row
05D6 D0E0       444            pop acc
05D8 E543       445       mov a, reflow_temp
05DA 120594     446            lcall SendToLCD
05DD            447       
05DD C0E0       448            push acc
05DF 740E       448            mov a, #14
05E1 14         448            dec a
05E2 120136     448            lcall ?Set_Cursor_2 ; Select column and row
05E5 D0E0       448            pop acc
05E7 E542       449       mov a, reflow_time
05E9 120594     450            lcall SendToLCD
05EC            451            
05EC 22         452            ret
05ED            453   
05ED            454   
05ED            455   ;-------------------------------------------------;
05ED            456   ; Display all values and temperatures to the LCD  ;
05ED            457   ;-------------------------------------------------;
05ED            458   Display_Data:
05ED C2EF       459            clr ADCF
05EF D2EE       460            setb ADCS ;  ADC start trigger signal
05F1 30EFFD     461       jnb ADCF, $ ; Wait for conversion complete
05F4            462       
05F4            463       ; Read the ADC result and store in [R1, R0]
05F4 E5C3       464       mov a, ADCRH   
05F6 C4         465       swap a
05F7 C0E0       466       push acc
05F9 540F       467       anl a, #0x0f
05FB F9         468       mov R1, a
05FC D0E0       469       pop acc
05FE 54F0       470       anl a, #0xf0
0600 45C2       471       orl a, ADCRL
0602 F8         472       mov R0, A
0603            473       
0603            474       ; Convert to voltage
0603 8830       475            mov x+0, R0
0605 8931       476            mov x+1, R1
0607            477            ; Pad other bits with zero
0607 753200     478            mov x+2, #0
060A 753300     479            mov x+3, #0
060D            480            
060D            481            ;lcall div32 ; Get V_out
060D            482            ; ; Calculate Temp based on V_out
060D            483            ; Load_y(27300) ; The reference temp K
060D            484            ; lcall sub32 ; Get Temp*0.01
060D            485            ; ; Change Temp*0.01 to Temp
060D            486            ; Load_y(100)
060D            487            ; lcall mul32
060D            488   
060D 75347C     489            mov y+0, #low (50300 % 0x10000) 
0610 7535C4     489            mov y+1, #high(50300 % 0x10000) 
0613 753600     489            mov y+2, #low (50300 / 0x10000) 
0616 753700     489            mov y+3, #high(50300 / 0x10000)  ; VCC voltage measured (equals 4.99V)
0619 1202EB     490            lcall mul32 ;multiplying ADC * Vref
061C 7534FF     491            mov y+0, #low (4095 % 0x10000) 
061F 75350F     491            mov y+1, #high(4095 % 0x10000) 
0622 753600     491            mov y+2, #low (4095 / 0x10000) 
0625 753700     491            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
0628 120378     492            lcall div32 ;now doing (ADC*Vref)/(4095)
062B            493            
062B 7534E8     494            mov y+0, #low (1000 % 0x10000) 
062E 753503     494            mov y+1, #high(1000 % 0x10000) 
0631 753600     494            mov y+2, #low (1000 / 0x10000) 
0634 753700     494            mov y+3, #high(1000 / 0x10000)  ; for converting volt to microvolt
0637 1202EB     495            lcall mul32 ;multiplying volts
063A            496            
063A 75340A     497            mov y+0, #low (10 % 0x10000) 
063D 753500     497            mov y+1, #high(10 % 0x10000) 
0640 753600     497            mov y+2, #low (10 / 0x10000) 
0643 753700     497            mov y+3, #high(10 / 0x10000) 
0646 1202EB     498            lcall mul32
0649            499            
0649            500            ;convert to temperature
0649 7534D0     501            mov y+0, #low (21200 % 0x10000) 
064C 753552     501            mov y+1, #high(21200 % 0x10000) 
064F 753600     501            mov y+2, #low (21200 / 0x10000) 
0652 753700     501            mov y+3, #high(21200 / 0x10000)  ;divide by the gain 
0655 120378     502            lcall div32 
0658 753429     503            mov y+0, #low (41 % 0x10000) 
065B 753500     503            mov y+1, #high(41 % 0x10000) 
065E 753600     503            mov y+2, #low (41 / 0x10000) 
0661 753700     503            mov y+3, #high(41 / 0x10000) ;load y = 41
0664 120378     504            lcall div32 ;divide by 41
0667            505            
0667 753410     506            mov y+0, #low (10000 % 0x10000) 
066A 753527     506            mov y+1, #high(10000 % 0x10000) 
066D 753600     506            mov y+2, #low (10000 / 0x10000) 
0670 753700     506            mov y+3, #high(10000 / 0x10000) 
0673 1202EB     507            lcall mul32
0676            508            
0676 753460     509            mov y+0, #low (220000 % 0x10000) 
0679 75355B     509            mov y+1, #high(220000 % 0x10000) 
067C 753603     509            mov y+2, #low (220000 / 0x10000) 
067F 753700     509            mov y+3, #high(220000 / 0x10000)  ;cold junction 19 deg C
0682 120236     510            lcall add32
0685            511   
0685            512   ; Convert to BCD and display
0685 120171     513            lcall hex2bcd
0688 120543     514            lcall Display_formated_BCD
068B            515   
068B 32         516            reti
068C            517   
068C            518   ;-----------------------------------------------------------------------------;
068C            519   ;Grabs the value in register a and then compares it to the current temperature;
068C            520   ;-----------------------------------------------------------------------------;
068C            521   
068C            522   Compare_temp:
068C 853A48     523            mov temp+0, bcd+2
068F 853B49     524            mov temp+1, bcd+3
0692 854838     525            mov bcd+0, temp+0
0695 854939     526            mov bcd+1, temp+1
0698 753A00     527            mov bcd+2,#0
069B 753B00     528            mov bcd+3,#0
069E 753C00     529            mov bcd+4,#0
06A1            530            
06A1 1201FA     531            lcall bcd2hex
06A4            532            
06A4 853034     533            mov y+0,x+0
06A7 853135     534            mov y+1,x+1
06AA 853236     535            mov y+2,x+2
06AD 853337     536            mov y+3,x+3
06B0            537            
06B0 F530       538            mov x+0,a
06B2 753100     539            mov x+1,#0
06B5 753200     540            mov x+2,#0
06B8 753300     541            mov x+3,#0
06BB            542            
06BB 120171     543            lcall hex2bcd
06BE 1202E1     544            lcall x_lteq_y
06C1            545   
06C1 32         546            reti
06C2            547   
06C2            548   Wait_1sec:
06C2            549            ; Wait 500 ms between conversions
06C2 7AFA       550            mov R2, #250
06C4 1204A1     551            lcall waitms
06C7 7AFA       552            mov R2, #250
06C9 1204A1     553            lcall waitms
06CC            554            ; Wait 500 ms between conversions
06CC 7AFA       555            mov R2, #250
06CE 1204A1     556            lcall waitms
06D1 7AFA       557            mov R2, #250
06D3 1204A1     558            lcall waitms
06D6 32         559            reti
06D7            560   
06D7            561   main:
06D7 75817F     562            mov sp, #0x7f
06DA 120447     563            lcall Init_All
06DD 1200F8     564       lcall LCD_4BIT
06E0 1203E1     565       lcall Timer0_Init
06E3 120404     566       lcall Timer2_Init
06E6 D2AF       567       setb EA   ; Enable Global interrupts
06E8            568       ; initial messages in LCD
06E8 C0E0       569            push acc
06EA 7401       569            mov a, #1
06EC 14         569            dec a
06ED 120138     569            lcall ?Set_Cursor_1 ; Select column and row
06F0 D0E0       569            pop acc
06F2 C083       570            push dph
06F4 C082       570            push dpl
06F6 C0E0       570            push acc
06F8 90002E     570            mov dptr, #To_Message
06FB 12012B     570            lcall ?Send_Constant_String
06FE D0E0       570            pop acc
0700 D082       570            pop dpl
0702 D083       570            pop dph
0704 C0E0       571            push acc
0706 7401       571            mov a, #1
0708 14         571            dec a
0709 120136     571            lcall ?Set_Cursor_2 ; Select column and row
070C D0E0       571            pop acc
070E C083       572            push dph
0710 C082       572            push dpl
0712 C0E0       572            push acc
0714 90003F     572            mov dptr, #Time_temp_display
0717 12012B     572            lcall ?Send_Constant_String
071A D0E0       572            pop acc
071C D082       572            pop dpl
071E D083       572            pop dph
0720 754B00     573       mov FSM_state,#0
0723 753F00     574            mov seconds, #0x00
0726 75458C     575            mov soak_temp, #0x8C ;140
0729 75443C     576            mov soak_time, #0x3C ; 60
072C 7543E6     577            mov reflow_temp, #0xE6 ; 230
072F 75421E     578            mov reflow_time, #0x1E ; 30
0732 753800     579            mov bcd,#0
0735            580            
0735 C208       581            clr start_stop_flag
0737 C207       582            clr FSM_start_flag
0739            583       
0739            584   ;---------------------------------;
0739            585   ;                FSM     funtion                               ;
0739            586   ;---------------------------------;
0739            587   FSM:
0739 E54B       588       mov a, FSM_state
073B            589   FSM_state0:
073B B40033     590       cjne a, #0, FSM_state1
073E 754700     591       mov pwm, #0 ; power variable
0741 1204A7     592            lcall LCD_PB ; calls and checks the pushbuttons
0744 1205B0     593            lcall Display_PushButtons_LCD ;Displays values in pushbuttons
0747            594            ;Set_Cursor(1, 4)
0747            595            ;lcall Display_Data
0747 300824     596       jnb start_stop_flag, FSM_state0_done
074A D207       597       setb FSM_start_flag
074C 753F00     598       mov seconds, #0x00     ; set time to 0
074F 754B01     599       mov FSM_state, #1   ; set FSM_state to 1, next state is state1
0752 C0E0       600            push acc
0754 7401       600            mov a, #1
0756 14         600            dec a
0757 120136     600            lcall ?Set_Cursor_2 ; Select column and row
075A D0E0       600            pop acc
075C C083       601            push dph
075E C082       601            push dpl
0760 C0E0       601            push acc
0762 900050     601            mov dptr, #Ramp_to_soak
0765 12012B     601            lcall ?Send_Constant_String
0768 D0E0       601            pop acc
076A D082       601            pop dpl
076C D083       601            pop dph
076E            602   FSM_state0_done:
076E 020739     603       ljmp FSM   ;jump back to FSM and reload FSM_state to a
0771            604   
0771            605   FSM_state1:
0771 B40147     606       cjne a, #1, FSM_state2
0774 754764     607       mov pwm, #100
0777 C3         608       clr c
0778 300834     609       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
077B 743C       610       mov a, #0x3C
077D 953F       611       subb a, seconds
077F 401A       612       jc abort
0781            613   continue:
0781 C3         614       clr c   ; ! i don't know what is c
0782 300113     615            jnb s_flag, FSM_state1_done
0785 C201       616            clr s_flag
0787 1205ED     617            lcall Display_Data
078A E545       618            mov a, soak_temp    ; set a to soak temp
078C 12068C     619            lcall Compare_temp
078F 300006     620       jnb mf, FSM_state1_done
0792 753F00     621       mov seconds, #0x00     ; set time to 0
0795 754B02     622       mov FSM_state, #2
0798            623   FSM_state1_done:
0798 020739     624       ljmp FSM
079B            625   abort:
079B 7432       626       mov a, #0x32  ; set a to 50 degree
079D 3001F8     627            jnb s_flag, FSM_state1_done
07A0 1205ED     628            lcall Display_Data
07A3 12068C     629            lcall Compare_temp
07A6 2000D8     630            jb mf, continue ; if temp is larger then 50 degree, go back to continue
07A9 754B00     631       mov FSM_state, #0   ; abort the FSM
07AC 0206D7     632            ljmp main
07AF            633   
07AF            634   stop_state:
07AF C2CA       635       clr TR2
07B1 300805     636       jnb start_stop_flag, stop
07B4 D2CA       637            setb TR2
07B6 020739     638            ljmp FSM
07B9            639   
07B9            640   stop:
07B9 80F4       641       sjmp stop_state
07BB            642   
07BB            643   FSM_state2:
07BB B4023A     644       cjne a, #2, FSM_state3
07BE 754714     645       mov pwm, #20
07C1 E544       646       mov a, soak_time    ; set a to soak time
07C3 C0E0       647            push acc
07C5 7401       647            mov a, #1
07C7 14         647            dec a
07C8 120136     647            lcall ?Set_Cursor_2 ; Select column and row
07CB D0E0       647            pop acc
07CD C083       648            push dph
07CF C082       648            push dpl
07D1 C0E0       648            push acc
07D3 900061     648            mov dptr, #Soak_display
07D6 12012B     648            lcall ?Send_Constant_String
07D9 D0E0       648            pop acc
07DB D082       648            pop dpl
07DD D083       648            pop dph
07DF C3         649       clr c   ; ! i don't know what is c 
07E0 300112     650            jnb s_flag, FSM_state2_done
07E3 C201       651            clr s_flag
07E5 1205ED     652            lcall Display_Data
07E8 3008C4     653       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
07EB 953F       654       subb a, seconds    ; temp is our currect sec
07ED 5006       655       jnc FSM_state2_done
07EF 753F00     656       mov seconds, #0x00     ; set time to 0
07F2 754B03     657       mov FSM_state, #3
07F5            658   FSM_state2_done:
07F5 020739     659       ljmp FSM
07F8            660   
07F8            661   FSM_state3:
07F8 B40342     662       cjne a, #3, FSM_state4
07FB 754764     663       mov pwm, #100
07FE C0E0       664            push acc
0800 7401       664            mov a, #1
0802 14         664            dec a
0803 120136     664            lcall ?Set_Cursor_2 ; Select column and row
0806 D0E0       664            pop acc
0808 C083       665            push dph
080A C082       665            push dpl
080C C0E0       665            push acc
080E 90006F     665            mov dptr, #Ramp_to_peak
0811 12012B     665            lcall ?Send_Constant_String
0814 D0E0       665            pop acc
0816 D082       665            pop dpl
0818 D083       665            pop dph
081A C3         666       clr c   ; ! i don't know what is c 
081B 300891     667       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
081E 300113     668            jnb s_flag, FSM_state3_done
0821 C201       669            clr s_flag
0823 1205ED     670            lcall Display_Data
0826 E543       671            mov a, reflow_temp    ; set a to reflow temp
0828 12068C     672            lcall Compare_temp
082B 300006     673       jnb mf, FSM_state3_done
082E 753F00     674       mov seconds, #0x00     ; set time to 0
0831 754B04     675       mov FSM_state, #4
0834            676   FSM_state3_done:
0834 020739     677       ljmp FSM
0837            678            
0837            679   intermediate_state_0:
0837 02073B     680            ljmp FSM_state0
083A            681   
083A            682   intermediate_stop_jump:
083A 0207AF     683            ljmp stop_state
083D            684   
083D            685   FSM_state4:
083D B4043A     686       cjne a, #4, FSM_state5
0840 754714     687       mov pwm, #20
0843 C0E0       688            push acc
0845 7401       688            mov a, #1
0847 14         688            dec a
0848 120136     688            lcall ?Set_Cursor_2 ; Select column and row
084B D0E0       688            pop acc
084D C083       689            push dph
084F C082       689            push dpl
0851 C0E0       689            push acc
0853 900080     689            mov dptr, #Reflow_display
0856 12012B     689            lcall ?Send_Constant_String
0859 D0E0       689            pop acc
085B D082       689            pop dpl
085D D083       689            pop dph
085F C3         690       clr c   ; ! i don't know what is c 
0860 300114     691            jnb s_flag, FSM_state4_done
0863 C201       692            clr s_flag
0865 1205ED     693            lcall Display_Data
0868 3008CF     694       jnb start_stop_flag, intermediate_stop_jump; checks the flag if 0, then means stop was pressed, if 1 keep on going
086B E542       695            mov a, reflow_time    ; set a to reflow time
086D 953F       696       subb a, seconds    ; temp is our currect sec
086F 5006       697       jnc FSM_state4_done
0871 753F00     698       mov seconds, #0x00     ; set time to 0
0874 754B05     699       mov FSM_state, #5
0877            700   FSM_state4_done:
0877 020739     701       ljmp FSM
087A            702   
087A            703   FSM_state5:
087A B405BA     704       cjne a, #5, intermediate_state_0
087D 754700     705       mov pwm, #0
0880            706       
0880 C0E0       707            push acc
0882 7401       707            mov a, #1
0884 14         707            dec a
0885 120136     707            lcall ?Set_Cursor_2 ; Select column and row
0888 D0E0       707            pop acc
088A C083       708            push dph
088C C082       708            push dpl
088E C0E0       708            push acc
0890 90008F     708            mov dptr, #Cooling_display
0893 12012B     708            lcall ?Send_Constant_String
0896 D0E0       708            pop acc
0898 D082       708            pop dpl
089A D083       708            pop dph
089C C3         709       clr c   ; ! i don't know what is c
089D 30089A     710       jnb start_stop_flag, intermediate_stop_jump ; checks the flag if 0, then means stop was pressed, if 1 keep on going 
08A0 300113     711            jnb s_flag, FSM_state5_done
08A3 C201       712            clr s_flag
08A5 1205ED     713            lcall Display_Data
08A8 743C       714            mov a, #0x3C    ; set a to 60
08AA 12068C     715            lcall Compare_temp
08AD            716   
08AD 200006     717       jb mf, FSM_state5_done
08B0 753F00     718       mov seconds, #0x00     ; set time to 0
08B3 754B00     719       mov FSM_state, #0
08B6            720   FSM_state5_done:
08B6 0206D7     721       ljmp main
08B9            722   EN
