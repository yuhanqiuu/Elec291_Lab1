                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             21   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             22   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             23   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             25   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             26   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             27   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             28   
0000             29   ;---------------------------------;
0000             30   ; Define any buttons & pins here  ;
0000             31   ;---------------------------------;
0000             32   
0000             33   SOUND_OUT   equ p1.7 ; speaker pin
0000             34   ; Output
0000             35   PWM_OUT    EQU P1.0 ; Logic 1=oven on
0000             36   ;---------------------------------------------
0000             37   ORG 0x0000
0000 02060C      38            ljmp main
0003             39   
0003             40   ;---------------------------------;
0003             41   ; Define any constant string here ;
0003             42   ;---------------------------------;
0003             43   ;                          1234567890123456    <- This helps determine the location of the counter
0003 546F3D78    44   To_Message:        db 'To=xxxC Tj= xxC ', 0
     78784320
     546A3D20
     78784320
     00
0014 73787878    45   Time_temp_display:db 'sxxx,xx rxxx,xx ', 0 ; soak temp,time reflow temp,time
     2C787820
     72787878
     2C787820
     00
0025 52616D70    46   Ramp_to_soak:      db 'RampToSoak s=xxx', 0 ; state 1 display
     546F536F
     616B2073
     3D787878
     00
0036 536F616B    47   Soak_display:      db 'Soak               s=xxx', 0 ; state 2 display
     20090920
     733D7878
     7800
0044 52616D70    48   Ramp_to_peak:      db 'RampToPeak s=xxx', 0 ; state 3 display
     546F5065
     616B2073
     3D787878
     00
0055 5265666C    49   Reflow_display:   db 'Reflow      s=xxx', 0 ; state 4 display
     6F772009
     20733D78
     787800
0064 436F6F6C    50   Cooling_display:  db 'Cooling     s=xxx', 0 ; state 5 display
     696E6720
     0920733D
     78787800
0074             51   ;---------------------------------------------
0074             52   cseg
0074             53   
0074             54   LCD_RS equ P1.3
0074             55   LCD_E  equ P1.4
0074             56   LCD_D4 equ P0.0
0074             57   LCD_D5 equ P0.1
0074             58   LCD_D6 equ P0.2
0074             59   LCD_D7 equ P0.3
0074             60   
                 62   	$LIST
0128             64   
0128             65   ;---------------------------------;
0128             66   ; Define variables here           ;
0128             67   ;---------------------------------;
0128             68   ; These register definitions needed by 'math32.inc'
0030             69   DSEG at 30H
0030             70   x:   ds 4
0034             71   y:   ds 4
0038             72   bcd: ds 5   ;temperature variable for reading
003D             73   Count1ms:     ds 2 ; Used to determine when one second has passed
003F             74   seconds: ds 1
0040             75   VLED_ADC: ds 2
0042             76   reflow_time: ds 1 ; time parameter for reflow    
0043             77   reflow_temp: ds 1 ; temp parameter for reflow
0044             78   soak_time: ds 1 ; time parameter for soak
0045             79   soak_temp: ds 1 ; temp parameter for soak
0046             80   pwm_counter: ds 1 ; power counter
0047             81   pwm: ds 1 ; variable to count the power percentage
0048             82   temp: ds 3
004B             83   FSM_state: ds 1
004C             84   ;---------------------------------------------
004C             85   
004C             86   ;---------------------------------;
004C             87   ; Define flags here               ;
004C             88   ;---------------------------------;
0000             89   BSEG
0000             90   mf: dbit 1
0001             91   s_flag: dbit 1 ; Set to one in the ISR every time 1000 ms had passed
0002             92   PB0: dbit 1      ; start/stop
0003             93   PB1: dbit 1      ; increment reflow time
0004             94   PB2: dbit 1      ; increment reflow temp
0005             95   PB3: dbit 1      ; increment soak time
0006             96   PB4: dbit 1      ; increment soak temp
0007             97   start_stop_flag: dbit 1 ; Set to one if button is pressed to start, press again to stop
0008             98   ;---------------------------------------------
0008             99   
                546   $LIST
                101   $LIST
0398            103   
0398            104   ;---------------------------------;
0398            105   ; Routine to initialize the ISR   ;
0398            106   ; for timer 0                     ;
0398            107   ;---------------------------------;
0398            108   Timer0_Init:
0398 438E08     109            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
039B E589       110            mov a, TMOD
039D 54F0       111            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
039F 4401       112            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03A1 F589       113            mov TMOD, a
03A3 758CF0     114            mov TH0, #high(TIMER0_RELOAD)
03A6 758A2C     115            mov TL0, #low(TIMER0_RELOAD)
03A9            116            ; Enable the timer and interrupts
03A9 D2A9       117       setb ET0  ; Enable timer 0 interrupt
03AB D28C       118       setb TR0  ; Start timer 0
03AD 22         119            ret
03AE            120   
03AE            121   ;---------------------------------;
03AE            122   ; ISR for timer 0.  Set to execute;
03AE            123   ; every 1/4096Hz to generate a    ;
03AE            124   ; 2048 Hz wave at pin SOUND_OUT   ;
03AE            125   ;---------------------------------;
03AE            126   Timer0_ISR:
03AE            127            ;clr TF0  ; According to the data sheet this is done for us already.
03AE            128            ; Timer 0 doesn't have 16-bit auto-reload, so
03AE C28C       129            clr TR0
03B0 758CF0     130            mov TH0, #high(TIMER0_RELOAD)
03B3 758A2C     131            mov TL0, #low(TIMER0_RELOAD)
03B6 D28C       132            setb TR0
03B8 B297       133            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
03BA 32         134            reti
03BB            135   
03BB            136   ;---------------------------------;
03BB            137   ; Routine to initialize the ISR   ;
03BB            138   ; for timer 2                     ;
03BB            139   ;---------------------------------;
03BB            140   Timer2_Init:
03BB 75C800     141            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
03BE 75CDBF     142            mov TH2, #high(TIMER2_RELOAD)
03C1 75CC28     143            mov TL2, #low(TIMER2_RELOAD)
03C4            144            ; Set the reload value
03C4 43C980     145            orl T2MOD, #0x80 ; Enable timer 2 autoreload
03C7 75CBBF     146            mov RCMP2H, #high(TIMER2_RELOAD)
03CA 75CA28     147            mov RCMP2L, #low(TIMER2_RELOAD)
03CD            148            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
03CD E4         149            clr a
03CE F53D       150            mov Count1ms+0, a
03D0 F53E       151            mov Count1ms+1, a
03D2 754700     152            mov pwm, #0
03D5            153            ; Enable the timer and interrupts
03D5 439B80     154            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
03D8 D2CA       155       setb TR2  ; Enable timer 2
03DA 22         156            ret
03DB            157   
03DB            158   ;---------------------------------;
03DB            159   ; ISR for timer 2 ;
03DB            160   ;---------------------------------;
03DB            161   Timer2_ISR:
03DB C2CF       162            clr TF2 ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR. It is bit addressable.
03DD B284       163            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
03DF            164                    
03DF            165            ; The two registers used in the ISR must be saved in the stack
03DF C0D0       166            push psw
03E1 C0E0       167            push acc
03E3 0546       168            inc pwm_counter
03E5 C3         169            clr c
03E6 E547       170            mov a, pwm
03E8 9546       171            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
03EA B3         172            cpl c
03EB 9290       173            mov PWM_OUT, c
03ED E546       174            mov a, pwm_counter
03EF B46407     175            cjne a, #100, Timer2_ISR_done
03F2 754600     176            mov pwm_counter, #0
03F5 053F       177            inc seconds ; It is super easy to keep a seconds count here
03F7 D201       178            setb s_flag
03F9            179   
03F9            180   Timer2_ISR_done:
03F9 D0E0       181            pop acc
03FB D0D0       182            pop psw
03FD 32         183            reti
03FE            184   
03FE            185   ;---------------------------------;
03FE            186   ; Temperature senseor function    ;
03FE            187   ;---------------------------------;
03FE            188   Init_All:
03FE            189            ; Configure all the pins for biderectional I/O
03FE 75AC00     190            mov     P3M1, #0x00
0401 75AD00     191            mov     P3M2, #0x00
0404 75B300     192            mov     P1M1, #0x00
0407 75B400     193            mov     P1M2, #0x00
040A 75B100     194            mov     P0M1, #0x00
040D 75B200     195            mov     P0M2, #0x00
0410            196            
0410 438E10     197            orl     CKCON, #0x10 ; CLK is the input for timer 1
0413 438780     198            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0416 759852     199            mov     SCON, #0x52
0419 53C4DF     200            anl     T3CON, #0b11011111
041C 53890F     201            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
041F 438920     202            orl     TMOD, #0x20 ; Timer 1 Mode 2
0422 758DF7     203            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0425 D28E       204            setb TR1
0427            205            
0427            206            ; Using timer 0 for delay functions.  Initialize here:
0427 C28C       207            clr     TR0 ; Stop timer 0
0429 438E08     208            orl     CKCON,#0x08 ; CLK is the input for timer 0
042C 5389F0     209            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
042F 438901     210            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0432            211            
0432            212            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
0432 43B382     213            orl     P1M1, #0b10000010
0435 53B47D     214            anl     P1M2, #0b01111101
0438            215            
0438            216            ; Initialize and start the ADC:
0438 53E8F0     217            anl ADCCON0, #0xF0
043B 43E807     218            orl ADCCON0, #0x07 ; Select channel 7
043E            219            ; AINDIDS select if some pins are analog inputs or digital I/O:
043E 75F600     220            mov AINDIDS, #0x00 ; Disable all analog inputs
0441 43F681     221            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
0444 43E101     222            orl ADCCON1, #0x01 ; Enable ADC
0447            223            
0447 22         224            ret
0448            225            
0448            226   ; Send a character using the serial port
0448            227   putchar:
0448 3099FD     228       jnb TI, putchar
044B C299       229       clr TI
044D F599       230       mov SBUF, a
044F 22         231       ret
0450            232   
0450            233   wait_1ms:
0450 C28C       234            clr     TR0 ; Stop timer 0
0452 C28D       235            clr     TF0 ; Clear overflow flag
0454 758CBF     236            mov     TH0, #high(TIMER0_RELOAD_1MS)
0457 758A28     237            mov     TL0,#low(TIMER0_RELOAD_1MS)
045A D28C       238            setb TR0
045C 308DFD     239            jnb     TF0, $ ; Wait for overflow
045F 22         240            ret
0460            241   
0460            242   ; Wait the number of miliseconds in R2
0460            243   waitms:
0460 120450     244            lcall wait_1ms
0463 DAFB       245            djnz R2, waitms
0465 22         246            ret
0466            247   
0466            248   ;---------------------------------;
0466            249   ;         5_pushbuttons function               ;
0466            250   ;---------------------------------;
0466            251   LCD_PB:
0466            252            ; Set variables to 1: 'no push button pressed'
0466 D202       253            setb PB0
0468 D203       254            setb PB1
046A D204       255            setb PB2
046C D205       256            setb PB3
046E D206       257            setb PB4
0470            258            ; The input pin used to check set to '1'
0470 D295       259            setb P1.5
0472            260            
0472            261            ; Check if any push button is pressed
0472 C280       262            clr P0.0
0474 C281       263            clr P0.1
0476 C282       264            clr P0.2
0478 C283       265            clr P0.3
047A C293       266            clr P1.3
047C 209549     267            jb P1.5, LCD_PB_Done
047F            268   
047F            269            ; Debounce
047F 7A32       270            mov R2, #50
0481 120460     271            lcall waitms
0484 209541     272            jb P1.5, LCD_PB_Done
0487            273   
0487            274            ; Set the LCD data pins to logic 1
0487 D280       275            setb P0.0
0489 D281       276            setb P0.1
048B D282       277            setb P0.2
048D D283       278            setb P0.3
048F D293       279            setb P1.3
0491            280            
0491            281            ; Check the push buttons one by one
0491 C293       282            clr P1.3
0493 A295       283            mov c, P1.5
0495 9206       284            mov PB4, c
0497 D293       285            setb P1.3
0499 30062D     286            jnb PB4,increment_soak_temp
049C            287   
049C C280       288            clr P0.0
049E A295       289            mov c, P1.5
04A0 9205       290            mov PB3, c
04A2 D280       291            setb P0.0
04A4 30052E     292            jnb PB3, increment_soak_time
04A7            293            
04A7 C281       294            clr P0.1
04A9 A295       295            mov c, P1.5
04AB 9204       296            mov PB2, c
04AD D281       297            setb P0.1
04AF 30042F     298            jnb PB2, increment_reflow_temp
04B2            299            
04B2 C282       300            clr P0.2
04B4 A295       301            mov c, P1.5
04B6 9203       302            mov PB1, c
04B8 D282       303            setb P0.2
04BA 300330     304            jnb PB1, increment_reflow_time
04BD            305            
04BD C283       306            clr P0.3
04BF A295       307            mov c, P1.5
04C1 9202       308            mov PB0, c
04C3 D283       309            setb P0.3
04C5 300231     310            jnb PB0, start_stop
04C8            311   
04C8            312   
04C8            313   LCD_PB_Done:             
04C8 22         314            ret
04C9            315   
04C9            316   increment_soak_temp:
04C9 0545       317            inc soak_temp
04CB E545       318            mov a, soak_temp
04CD B4F0F8     319            cjne a, #240, LCD_PB_Done
04D0 754500     320            mov soak_temp, #0x00
04D3 80F3       321            sjmp LCD_PB_Done
04D5            322   increment_soak_time:
04D5 0544       323            inc soak_time
04D7 E544       324            mov a, soak_time
04D9 B478EC     325            cjne a, #120, LCD_PB_Done
04DC 754400     326            mov soak_time, #0x00
04DF 80E7       327            sjmp LCD_PB_Done
04E1            328   increment_reflow_temp: 
04E1 0543       329            inc reflow_temp
04E3 E543       330            mov a, reflow_temp
04E5 B4F0E0     331            cjne a, #240, LCD_PB_Done
04E8 754300     332            mov reflow_temp, #0x00
04EB 80DB       333            sjmp LCD_PB_Done
04ED            334   increment_reflow_time:
04ED 0542       335            inc reflow_time
04EF E542       336            mov a, reflow_time
04F1 B44BD4     337            cjne a, #75, LCD_PB_Done
04F4 754200     338            mov reflow_time, #0x00
04F7 80CF       339            sjmp LCD_PB_Done
04F9            340   
04F9            341   start_stop:
04F9 B207       342            cpl start_stop_flag
04FB 80CB       343            sjmp LCD_PB_Done
04FD            344   
04FD            345   ;---------------------------------;
04FD            346   ; Send a BCD number to PuTTY      ;
04FD            347   ;---------------------------------;
                348   Send_BCD mac
                349   	push ar0
                350   	mov r0, %0
                351   	lcall ?Send_BCD
                352   	pop ar0
                353   endmac
04FD            354   
04FD            355   ?Send_BCD:
04FD C0E0       356            push acc
04FF            357            ; Write most significant digit
04FF E8         358            mov a, r0
0500 C4         359            swap a
0501 540F       360            anl a, #0fh
0503 4430       361            orl a, #30h
0505 120448     362            lcall putchar
0508            363            ; write least significant digit
0508 E8         364            mov a, r0
0509 540F       365            anl a, #0fh
050B 4430       366            orl a, #30h
050D 120448     367            lcall putchar
0510 D0E0       368            pop acc
0512 22         369            ret
0513            370   
0513            371   ; We can display a number any way we want.  In this case with
0513            372   ; four decimal places.
0513            373   Display_formated_BCD:
0513 C0E0       374            push acc
0515 7403       374            mov a, #3
0517 14         374            dec a
0518 12010D     374            lcall ?Set_Cursor_1 ; Select column and row
051B D0E0       374            pop acc
051D C000       375            push ar0
051F A83A       375            mov r0, bcd+2
0521 120112     375            lcall ?Display_BCD
0524 D000       375            pop ar0
0526 C0E0       376            push acc
0528 742E       376            mov a, #'.'
052A 1200C3     376            lcall ?WriteData
052D D0E0       376            pop acc
052F C000       377            push ar0
0531 A839       377            mov r0, bcd+1
0533 120112     377            lcall ?Display_BCD
0536 D000       377            pop ar0
0538 C000       378            push ar0
053A A838       378            mov r0, bcd+0
053C 120112     378            lcall ?Display_BCD
053F D000       378            pop ar0
0541 C0E0       379            push acc
0543 740A       379            mov a, #10
0545 14         379            dec a
0546 12010B     379            lcall ?Set_Cursor_2 ; Select column and row
0549 D0E0       379            pop acc
054B            380            ;Display_char(#'=')
054B 22         381            ret
054C            382   
054C            383   Read_ADC:
054C C2EF       384            clr ADCF
054E D2EE       385            setb ADCS ;  ADC start trigger signal
0550 30EFFD     386       jnb ADCF, $ ; Wait for conversion complete
0553            387       
0553            388       ; Read the ADC result and store in [R1, R0]
0553 E5C2       389       mov a, ADCRL
0555 540F       390       anl a, #0x0f
0557 F8         391       mov R0, a
0558 E5C3       392       mov a, ADCRH   
055A C4         393       swap a
055B C0E0       394       push acc
055D 540F       395       anl a, #0x0f
055F F9         396       mov R1, a
0560 D0E0       397       pop acc
0562 54F0       398       anl a, #0xf0
0564 48         399       orl a, R0
0565 F8         400       mov R0, A
0566 22         401            ret
0567            402   
0567            403   ;-------------------------------------------------;
0567            404   ; Display all values and temperatures to the LCD  ;
0567            405   ;-------------------------------------------------;
0567            406   Display_Data:
0567            407            ; Read the 2.08V LED voltage connected to AIN0 on pin 6
0567 53E8F0     408            anl ADCCON0, #0xF0
056A 43E800     409            orl ADCCON0, #0x00 ; Select channel 0
056D            410   
056D 12054C     411            lcall Read_ADC
0570            412            ; Save result for later use
0570 8840       413            mov VLED_ADC+0, R0
0572 8941       414            mov VLED_ADC+1, R1
0574            415   
0574            416            ; Read the signal connected to AIN7
0574 53E8F0     417            anl ADCCON0, #0xF0
0577 43E807     418            orl ADCCON0, #0x07 ; Select channel 7
057A 12054C     419            lcall Read_ADC
057D            420       
057D            421       ; Convert to voltage
057D 8830       422            mov x+0, R0
057F 8931       423            mov x+1, R1
0581            424            ; Pad other bits with zero
0581 753200     425            mov x+2, #0
0584 753300     426            mov x+3, #0
0587 753404     427            mov y+0, #low (20740 % 0x10000) 
058A 753551     427            mov y+1, #high(20740 % 0x10000) 
058D 753600     427            mov y+2, #low (20740 / 0x10000) 
0590 753700     427            mov y+3, #high(20740 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
0593 1202A2     428            lcall mul32 ; Get ADC * V_ref
0596            429            ; Retrive the ADC LED value
0596 854034     430            mov y+0, VLED_ADC+0
0599 854135     431            mov y+1, VLED_ADC+1
059C            432            ; Pad other bits with zero
059C 753600     433            mov y+2, #0
059F 753700     434            mov y+3, #0
05A2 12032F     435            lcall div32 ; Get V_out
05A5            436            ; Calculate Temp based on V_out
05A5 7534A4     437            mov y+0, #low (27300 % 0x10000) 
05A8 75356A     437            mov y+1, #high(27300 % 0x10000) 
05AB 753600     437            mov y+2, #low (27300 / 0x10000) 
05AE 753700     437            mov y+3, #high(27300 / 0x10000)  ; The reference temp K
05B1 12020E     438            lcall sub32 ; Get Temp*0.01
05B4            439            ; Change Temp*0.01 to Temp
05B4 753464     440            mov y+0, #low (100 % 0x10000) 
05B7 753500     440            mov y+1, #high(100 % 0x10000) 
05BA 753600     440            mov y+2, #low (100 / 0x10000) 
05BD 753700     440            mov y+3, #high(100 / 0x10000) 
05C0 1202A2     441            lcall mul32
05C3            442   
05C3            443            ; Convert to BCD and display
05C3 120128     444            lcall hex2bcd
05C6 120513     445            lcall Display_formated_BCD
05C9 C000       446            push ar0
05CB A83B       446            mov r0, bcd+3
05CD 1204FD     446            lcall ?Send_BCD
05D0 D000       446            pop ar0
05D2 C000       447            push ar0
05D4 A83A       447            mov r0, bcd+2
05D6 1204FD     447            lcall ?Send_BCD
05D9 D000       447            pop ar0
05DB C000       448            push ar0
05DD A839       448            mov r0, bcd+1
05DF 1204FD     448            lcall ?Send_BCD
05E2 D000       448            pop ar0
05E4            449            
05E4 740D       450            mov a, #'\r' ; Return character
05E6 120448     451            lcall putchar
05E9 740A       452            mov a, #'\n' ; New-line character
05EB 120448     453            lcall putchar
05EE            454   
05EE C0E0       455            push acc
05F0 7403       455            mov a, #3
05F2 14         455            dec a
05F3 12010B     455            lcall ?Set_Cursor_2 ; Select column and row
05F6 D0E0       455            pop acc         ; Display the amount of seconds that has passed from timer2
05F8 C000       456            push ar0
05FA 783F       456            mov r0, #seconds
05FC 120112     456            lcall ?Display_BCD
05FF D000       456            pop ar0
0601            457            
0601            458            ; Wait 500 ms between conversions
0601 7AFA       459            mov R2, #250
0603 120460     460            lcall waitms
0606 7AFA       461            mov R2, #250
0608 120460     462            lcall waitms
060B            463            
060B 32         464            reti
060C            465   
060C            466   main:
060C 75817F     467            mov sp, #0x7f
060F 1203FE     468            lcall Init_All
0612 1200CD     469       lcall LCD_4BIT
0615 120398     470       lcall Timer0_Init
0618 1203BB     471       lcall Timer2_Init
061B D2AF       472       setb EA   ; Enable Global interrupts
061D            473       ; initial messages in LCD
061D C0E0       474            push acc
061F 7401       474            mov a, #1
0621 14         474            dec a
0622 12010D     474            lcall ?Set_Cursor_1 ; Select column and row
0625 D0E0       474            pop acc
0627 C083       475            push dph
0629 C082       475            push dpl
062B C0E0       475            push acc
062D 900003     475            mov dptr, #To_Message
0630 120100     475            lcall ?Send_Constant_String
0633 D0E0       475            pop acc
0635 D082       475            pop dpl
0637 D083       475            pop dph
0639 C0E0       476            push acc
063B 7401       476            mov a, #1
063D 14         476            dec a
063E 12010B     476            lcall ?Set_Cursor_2 ; Select column and row
0641 D0E0       476            pop acc
0643 C083       477            push dph
0645 C082       477            push dpl
0647 C0E0       477            push acc
0649 900014     477            mov dptr, #Time_temp_display
064C 120100     477            lcall ?Send_Constant_String
064F D0E0       477            pop acc
0651 D082       477            pop dpl
0653 D083       477            pop dph
0655            478            
0655 753F00     479            mov seconds, #0x00
0658 75458C     480            mov soak_temp, #0140 
065B 754460     481            mov soak_time, #0x60
065E 7543E6     482            mov reflow_temp, #0230
0661 754230     483            mov reflow_time, #0x30
0664 D2CA       484            setb TR2
0666            485       
0666            486   ;---------------------------------;
0666            487   ;                FSM     funtion                               ;
0666            488   ;---------------------------------;
0666            489   FSM:
0666 E54B       490       mov a, FSM_state
0668            491   FSM_state0:
0668 B4000F     492       cjne a, #0, FSM_state1
066B 754700     493       mov pwm, #0 ; power variable
066E            494   
066E 300706     495       jnb start_stop_flag, FSM_state0_done
0671 753F00     496       mov seconds, #0     ; set time to 0
0674 754B01     497       mov FSM_state, #1   ; set FSM_state to 1, next state is state1
0677            498   FSM_state0_done:
0677 020666     499       ljmp FSM    ;jump back to FSM and reload FSM_state to a
067A            500   
067A            501   FSM_state1:
067A B4014E     502       cjne a, #1, FSM_state2
067D 754764     503       mov pwm, #100
0680 C0E0       504            push acc
0682 7401       504            mov a, #1
0684 14         504            dec a
0685 12010B     504            lcall ?Set_Cursor_2 ; Select column and row
0688 D0E0       504            pop acc
068A C083       505            push dph
068C C082       505            push dpl
068E C0E0       505            push acc
0690 900025     505            mov dptr, #Ramp_to_soak
0693 120100     505            lcall ?Send_Constant_String
0696 D0E0       505            pop acc
0698 D082       505            pop dpl
069A D083       505            pop dph
069C C3         506       clr c
069D 30071F     507       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
06A0 7460       508       mov a, #0x60
06A2 953F       509       subb a, seconds
06A4 4010       510       jc abort
06A6            511   continue:
06A6 C3         512       clr c   ; ! i don't know what is c
06A7 E545       513       mov a, soak_temp    ; set a to soak temp
06A9 9548       514       subb a, temp    ; temp is our currect temp
06AB 5006       515       jnc FSM_state1_done
06AD 753F00     516       mov seconds, #0     ; set time to 0
06B0 754B02     517       mov FSM_state, #2
06B3            518   FSM_state1_done:
06B3 020666     519       ljmp FSM
06B6            520   abort:
06B6 7432       521       mov a, #50  ; set a to 50 degree
06B8 9548       522       subb a, temp
06BA 40EA       523       jc continue     ; if temp is larger then 50 degree, go back to continue
06BC 754B00     524       mov FSM_state, #0   ; abort the FSM
06BF            525   
06BF            526   stop_state:
06BF C2CA       527       clr TR2
06C1 300705     528       jnb start_stop_flag, stop
06C4 D2CA       529            setb TR2
06C6 020666     530            ljmp FSM
06C9            531   
06C9            532   stop:
06C9 80F4       533       sjmp stop_state
06CB            534   
06CB            535   FSM_state2:
06CB B40232     536       cjne a, #2, FSM_state3
06CE 754714     537       mov pwm, #20
06D1 E544       538       mov a, soak_time    ; set a to soak time
06D3 C0E0       539            push acc
06D5 7401       539            mov a, #1
06D7 14         539            dec a
06D8 12010B     539            lcall ?Set_Cursor_2 ; Select column and row
06DB D0E0       539            pop acc
06DD C083       540            push dph
06DF C082       540            push dpl
06E1 C0E0       540            push acc
06E3 900036     540            mov dptr, #Soak_display
06E6 120100     540            lcall ?Send_Constant_String
06E9 D0E0       540            pop acc
06EB D082       540            pop dpl
06ED D083       540            pop dph
06EF C3         541       clr c   ; ! i don't know what is c 
06F0 3007CC     542       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
06F3 953F       543       subb a, seconds    ; temp is our currect sec
06F5 5006       544       jnc FSM_state2_done
06F7 753F00     545       mov seconds, #0     ; set time to 0
06FA 754B03     546       mov FSM_state, #3
06FD            547   FSM_state2_done:
06FD 020666     548       ljmp FSM
0700            549   
0700            550   FSM_state3:
0700 B40338     551       cjne a, #3, FSM_state4
0703 754764     552       mov pwm, #100
0706 E543       553       mov a, reflow_temp    ; set a to reflow temp
0708 C0E0       554            push acc
070A 7401       554            mov a, #1
070C 14         554            dec a
070D 12010B     554            lcall ?Set_Cursor_2 ; Select column and row
0710 D0E0       554            pop acc
0712 C083       555            push dph
0714 C082       555            push dpl
0716 C0E0       555            push acc
0718 900044     555            mov dptr, #Ramp_to_peak
071B 120100     555            lcall ?Send_Constant_String
071E D0E0       555            pop acc
0720 D082       555            pop dpl
0722 D083       555            pop dph
0724 C3         556       clr c   ; ! i don't know what is c 
0725 300797     557       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
0728 9548       558       subb a, temp    ; temp is our currect temp
072A 5006       559       jnc FSM_state3_done
072C 753F00     560       mov seconds, #0     ; set time to 0
072F 754B04     561       mov FSM_state, #4
0732            562   FSM_state3_done:
0732 020666     563       ljmp FSM
0735            564            
0735            565   intermediate_state_0:
0735 020668     566            ljmp FSM_state0
0738            567   
0738            568   intermediate_stop_jump:
0738 0206BF     569            ljmp stop_state
073B            570   
073B            571   FSM_state4:
073B B40432     572       cjne a, #4, FSM_state5
073E 754714     573       mov pwm, #20
0741 E542       574       mov a, reflow_time    ; set a to reflow time
0743 C0E0       575            push acc
0745 7401       575            mov a, #1
0747 14         575            dec a
0748 12010B     575            lcall ?Set_Cursor_2 ; Select column and row
074B D0E0       575            pop acc
074D C083       576            push dph
074F C082       576            push dpl
0751 C0E0       576            push acc
0753 900055     576            mov dptr, #Reflow_display
0756 120100     576            lcall ?Send_Constant_String
0759 D0E0       576            pop acc
075B D082       576            pop dpl
075D D083       576            pop dph
075F C3         577       clr c   ; ! i don't know what is c 
0760 3007D5     578       jnb start_stop_flag, intermediate_stop_jump; checks the flag if 0, then means stop was pressed, if 1 keep on going
0763 953F       579       subb a, seconds    ; temp is our currect sec
0765 5006       580       jnc FSM_state4_done
0767 753F00     581       mov seconds, #0     ; set time to 0
076A 754B05     582       mov FSM_state, #5
076D            583   FSM_state4_done:
076D 020666     584       ljmp FSM
0770            585   
0770            586   FSM_state5:
0770 B405C2     587       cjne a, #5, intermediate_state_0
0773 754700     588       mov pwm, #0
0776 743C       589       mov a, #60    ; set a to 60
0778 C0E0       590            push acc
077A 7401       590            mov a, #1
077C 14         590            dec a
077D 12010B     590            lcall ?Set_Cursor_2 ; Select column and row
0780 D0E0       590            pop acc
0782 C083       591            push dph
0784 C082       591            push dpl
0786 C0E0       591            push acc
0788 900064     591            mov dptr, #Cooling_display
078B 120100     591            lcall ?Send_Constant_String
078E D0E0       591            pop acc
0790 D082       591            pop dpl
0792 D083       591            pop dph
0794 C3         592       clr c   ; ! i don't know what is c
0795 3007A0     593       jnb start_stop_flag, intermediate_stop_jump ; checks the flag if 0, then means stop was pressed, if 1 keep on going 
0798 9548       594       subb a, temp    ; temp is our currect temp, need to be edit
079A 5006       595       jnc FSM_state5_done
079C 753F00     596       mov seconds, #0     ; set time to 0
079F 754B00     597       mov FSM_state, #0
07A2            598   FSM_state5_done:
07A2 020666     599       ljmp FSM
07A5            600   
07A5            601   EN
