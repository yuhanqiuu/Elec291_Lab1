                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             21   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             22   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             23   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             25   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             26   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             27   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             28   
0000             29   ;---------------------------------;
0000             30   ; Define any buttons & pins here  ;
0000             31   ;---------------------------------;
0000             32   ;!!!!!arbiturary value for now
0000             33   SOUND_OUT   equ p1.7 ; speaker pin
0000             34   ; Output
0000             35   PWM_OUT    EQU P1.0 ; Logic 1=oven on
0000             36   ;---------------------------------------------
0000             37   ORG 0x0000
0000 02062C      38            ljmp main
0003             39   
0003             40   ;---------------------------------;
0003             41   ; Define any constant string here ;
0003             42   ;---------------------------------;
0003             43   ;                          1234567890123456    <- This helps determine the location of the counter
0003 546F3D78    44   To_Message:        db 'To=xxxC Tj= xxC ', 0
     78784320
     546A3D20
     78784320
     00
0014 73787878    45   Time_temp_display:db 'sxxx,xx rxxx,xx ', 0 ; soak temp,time reflow temp,time
     2C787820
     72787878
     2C787820
     00
0025 52616D70    46   Ramp_to_soak:      db 'RampToSoak s=xxx', 0 ; state 1 display
     546F536F
     616B2073
     3D787878
     00
0036 536F616B    47   Soak_display:      db 'Soak               s=xxx', 0 ; state 2 display
     20090920
     733D7878
     7800
0044 52616D70    48   Ramp_to_peak:      db 'RampToPeak s=xxx', 0 ; state 3 display
     546F5065
     616B2073
     3D787878
     00
0055 5265666C    49   Reflow_display:   db 'Reflow      s=xxx', 0 ; state 4 display
     6F772009
     20733D78
     787800
0064 436F6F6C    50   Cooling_display:  db 'Cooling     s=xxx', 0 ; state 5 display
     696E6720
     0920733D
     78787800
0074             51   ;---------------------------------------------
0074             52   cseg
0074             53   
0074             54   LCD_RS equ P1.3
0074             55   LCD_E  equ P1.4
0074             56   LCD_D4 equ P0.0
0074             57   LCD_D5 equ P0.1
0074             58   LCD_D6 equ P0.2
0074             59   LCD_D7 equ P0.3
0074             60   
                 62   	$LIST
0128             64   
0128             65   ;---------------------------------;
0128             66   ; Define variables here           ;
0128             67   ;---------------------------------;
0128             68   ; These register definitions needed by 'math32.inc'
0030             69   DSEG at 30H
0030             70   x:   ds 4
0034             71   y:   ds 4
0038             72   bcd: ds 5   ;temperature variable for reading
003D             73   Count1ms:     ds 2 ; Used to determine when one second has passed
003F             74   seconds: ds 1
0040             75   VLED_ADC: ds 2
0042             76   reflow_time: ds 1 ; time parameter for reflow    
0043             77   reflow_temp: ds 1 ; temp parameter for reflow
0044             78   soak_time: ds 1 ; time parameter for soak
0045             79   soak_temp: ds 1 ; temp parameter for soak
0046             80   pwm_counter: ds 1 ; power counter
0047             81   pwm: ds 1 ; variable to count the power percentage
0048             82   temp: ds 3
004B             83   FSM_state: ds 1
004C             84   ;---------------------------------------------
004C             85   
004C             86   ;---------------------------------;
004C             87   ; Define flags here               ;
004C             88   ;---------------------------------;
0000             89   BSEG
0000             90   mf: dbit 1
0001             91   s_flag: dbit 1 ; Set to one in the ISR every time 1000 ms had passed
0002             92   PB0: dbit 1      ; start/stop
0003             93   PB1: dbit 1      ; increment reflow time
0004             94   PB2: dbit 1      ; increment reflow temp
0005             95   PB3: dbit 1      ; increment soak time
0006             96   PB4: dbit 1      ; increment soak temp
0007             97   start_stop_flag: dbit 1 ; Set to one if button is pressed to start, press again to stop
0008             98   ;---------------------------------------------
0008             99   
                546   $LIST
                101   $LIST
0398            103   
0398            104   ;---------------------------------;
0398            105   ; Routine to initialize the ISR   ;
0398            106   ; for timer 0                     ;
0398            107   ;---------------------------------;
0398            108   Timer0_Init:
0398 438E08     109            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
039B E589       110            mov a, TMOD
039D 54F0       111            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
039F 4401       112            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03A1 F589       113            mov TMOD, a
03A3 758CF0     114            mov TH0, #high(TIMER0_RELOAD)
03A6 758A2C     115            mov TL0, #low(TIMER0_RELOAD)
03A9            116            ; Enable the timer and interrupts
03A9 D2A9       117       setb ET0  ; Enable timer 0 interrupt
03AB D28C       118       setb TR0  ; Start timer 0
03AD 22         119            ret
03AE            120   
03AE            121   ;---------------------------------;
03AE            122   ; ISR for timer 0.  Set to execute;
03AE            123   ; every 1/4096Hz to generate a    ;
03AE            124   ; 2048 Hz wave at pin SOUND_OUT   ;
03AE            125   ;---------------------------------;
03AE            126   Timer0_ISR:
03AE            127            ;clr TF0  ; According to the data sheet this is done for us already.
03AE            128            ; Timer 0 doesn't have 16-bit auto-reload, so
03AE C28C       129            clr TR0
03B0 758CF0     130            mov TH0, #high(TIMER0_RELOAD)
03B3 758A2C     131            mov TL0, #low(TIMER0_RELOAD)
03B6 D28C       132            setb TR0
03B8 B297       133            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
03BA 32         134            reti
03BB            135   
03BB            136   ;---------------------------------;
03BB            137   ; Routine to initialize the ISR   ;
03BB            138   ; for timer 2                     ;
03BB            139   ;---------------------------------;
03BB            140   Timer2_Init:
03BB 75C800     141            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
03BE 75CDBF     142            mov TH2, #high(TIMER2_RELOAD)
03C1 75CC28     143            mov TL2, #low(TIMER2_RELOAD)
03C4            144            ; Set the reload value
03C4 43C980     145            orl T2MOD, #0x80 ; Enable timer 2 autoreload
03C7 75CBBF     146            mov RCMP2H, #high(TIMER2_RELOAD)
03CA 75CA28     147            mov RCMP2L, #low(TIMER2_RELOAD)
03CD            148            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
03CD E4         149            clr a
03CE F53D       150            mov Count1ms+0, a
03D0 F53E       151            mov Count1ms+1, a
03D2 754700     152            mov pwm, #0
03D5            153            ; Enable the timer and interrupts
03D5 439B80     154            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
03D8 D2CA       155       setb TR2  ; Enable timer 2
03DA 22         156            ret
03DB            157   
03DB            158   ;---------------------------------;
03DB            159   ; ISR for timer 2 ;
03DB            160   ;---------------------------------;
03DB            161   Timer2_ISR:
03DB C2CF       162            clr TF2 ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR. It is bit addressable.
03DD B284       163            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
03DF            164                    
03DF            165            ; The two registers used in the ISR must be saved in the stack
03DF C0D0       166            push psw
03E1 C0E0       167            push acc
03E3 0546       168            inc pwm_counter
03E5 C3         169            clr c
03E6 E547       170            mov a, pwm
03E8 9546       171            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
03EA B3         172            cpl c
03EB 9290       173            mov PWM_OUT, c
03ED E546       174            mov a, pwm_counter
03EF B46407     175            cjne a, #100, Timer2_ISR_done
03F2 754600     176            mov pwm_counter, #0
03F5 053F       177            inc seconds ; It is super easy to keep a seconds count here
03F7 D201       178            setb s_flag
03F9            179   
03F9            180   Timer2_ISR_done:
03F9 D0E0       181            pop acc
03FB D0D0       182            pop psw
03FD 32         183            reti
03FE            184   
03FE            185   ;---------------------------------;
03FE            186   ; Temperature senseor function    ;
03FE            187   ;---------------------------------;
03FE            188   Init_All:
03FE            189            ; Configure all the pins for biderectional I/O
03FE 75AC00     190            mov     P3M1, #0x00
0401 75AD00     191            mov     P3M2, #0x00
0404 75B300     192            mov     P1M1, #0x00
0407 75B400     193            mov     P1M2, #0x00
040A 75B100     194            mov     P0M1, #0x00
040D 75B200     195            mov     P0M2, #0x00
0410            196            
0410 438E10     197            orl     CKCON, #0x10 ; CLK is the input for timer 1
0413 438780     198            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
0416 759852     199            mov     SCON, #0x52
0419 53C4DF     200            anl     T3CON, #0b11011111
041C 53890F     201            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
041F 438920     202            orl     TMOD, #0x20 ; Timer 1 Mode 2
0422 758DF7     203            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0425 D28E       204            setb TR1
0427            205            
0427            206            ; Using timer 0 for delay functions.  Initialize here:
0427 C28C       207            clr     TR0 ; Stop timer 0
0429 438E08     208            orl     CKCON,#0x08 ; CLK is the input for timer 0
042C 5389F0     209            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
042F 438901     210            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0432            211            
0432            212            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
0432 43B382     213            orl     P1M1, #0b10000010
0435 53B47D     214            anl     P1M2, #0b01111101
0438            215            
0438            216            ; Initialize and start the ADC:
0438 53E8F0     217            anl ADCCON0, #0xF0
043B 43E807     218            orl ADCCON0, #0x07 ; Select channel 7
043E            219            ; AINDIDS select if some pins are analog inputs or digital I/O:
043E 75F600     220            mov AINDIDS, #0x00 ; Disable all analog inputs
0441 43F681     221            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
0444 43E101     222            orl ADCCON1, #0x01 ; Enable ADC
0447            223            
0447 22         224            ret
0448            225            
0448            226   ; Send a character using the serial port
0448            227   putchar:
0448 3099FD     228       jnb TI, putchar
044B C299       229       clr TI
044D F599       230       mov SBUF, a
044F 22         231       ret
0450            232   
0450            233   wait_1ms:
0450 C28C       234            clr     TR0 ; Stop timer 0
0452 C28D       235            clr     TF0 ; Clear overflow flag
0454 758CBF     236            mov     TH0, #high(TIMER0_RELOAD_1MS)
0457 758A28     237            mov     TL0,#low(TIMER0_RELOAD_1MS)
045A D28C       238            setb TR0
045C 308DFD     239            jnb     TF0, $ ; Wait for overflow
045F 22         240            ret
0460            241   
0460            242   ; Wait the number of miliseconds in R2
0460            243   waitms:
0460 120450     244            lcall wait_1ms
0463 DAFB       245            djnz R2, waitms
0465 22         246            ret
0466            247   
0466            248   ;---------------------------------;
0466            249   ;         5_pushbuttons function               ;
0466            250   ;---------------------------------;
0466            251   LCD_PB:
0466            252            ; Set variables to 1: 'no push button pressed'
0466 D202       253            setb PB0
0468 D203       254            setb PB1
046A D204       255            setb PB2
046C D205       256            setb PB3
046E D206       257            setb PB4
0470            258            ; The input pin used to check set to '1'
0470 D295       259            setb P1.5
0472            260            
0472            261            ; Check if any push button is pressed
0472 C280       262            clr P0.0
0474 C281       263            clr P0.1
0476 C282       264            clr P0.2
0478 C283       265            clr P0.3
047A C293       266            clr P1.3
047C 209549     267            jb P1.5, LCD_PB_Done
047F            268   
047F            269            ; Debounce
047F 7A32       270            mov R2, #50
0481 120460     271            lcall waitms
0484 209541     272            jb P1.5, LCD_PB_Done
0487            273   
0487            274            ; Set the LCD data pins to logic 1
0487 D280       275            setb P0.0
0489 D281       276            setb P0.1
048B D282       277            setb P0.2
048D D283       278            setb P0.3
048F D293       279            setb P1.3
0491            280            
0491            281            ; Check the push buttons one by one
0491 C293       282            clr P1.3
0493 A295       283            mov c, P1.5
0495 9206       284            mov PB4, c
0497 D293       285            setb P1.3
0499 30062D     286            jnb PB4,increment_soak_temp
049C            287   
049C C280       288            clr P0.0
049E A295       289            mov c, P1.5
04A0 9205       290            mov PB3, c
04A2 D280       291            setb P0.0
04A4 30052E     292            jnb PB3, increment_soak_time
04A7            293            
04A7 C281       294            clr P0.1
04A9 A295       295            mov c, P1.5
04AB 9204       296            mov PB2, c
04AD D281       297            setb P0.1
04AF 30042F     298            jnb PB2, increment_reflow_temp
04B2            299            
04B2 C282       300            clr P0.2
04B4 A295       301            mov c, P1.5
04B6 9203       302            mov PB1, c
04B8 D282       303            setb P0.2
04BA 300330     304            jnb PB1, increment_reflow_time
04BD            305            
04BD C283       306            clr P0.3
04BF A295       307            mov c, P1.5
04C1 9202       308            mov PB0, c
04C3 D283       309            setb P0.3
04C5 300231     310            jnb PB0, start_stop
04C8            311   
04C8            312   
04C8            313   LCD_PB_Done:             
04C8 22         314            ret
04C9            315   
04C9            316   increment_soak_temp:
04C9 0545       317            inc soak_temp
04CB E545       318            mov a, soak_temp
04CD B4F0F8     319            cjne a, #240, LCD_PB_Done
04D0 754500     320            mov soak_temp, #0x00
04D3 80F3       321            sjmp LCD_PB_Done
04D5            322   increment_soak_time:
04D5 0544       323            inc soak_time
04D7 E544       324            mov a, soak_time
04D9 B478EC     325            cjne a, #120, LCD_PB_Done
04DC 754400     326            mov soak_time, #0x00
04DF 80E7       327            sjmp LCD_PB_Done
04E1            328   increment_reflow_temp: 
04E1 0543       329            inc reflow_temp
04E3 E543       330            mov a, reflow_temp
04E5 B4F0E0     331            cjne a, #240, LCD_PB_Done
04E8 754300     332            mov reflow_temp, #0x00
04EB 80DB       333            sjmp LCD_PB_Done
04ED            334   increment_reflow_time:
04ED 0542       335            inc reflow_time
04EF E542       336            mov a, reflow_time
04F1 B44BD4     337            cjne a, #75, LCD_PB_Done
04F4 754200     338            mov reflow_time, #0x00
04F7 80CF       339            sjmp LCD_PB_Done
04F9            340   
04F9            341   start_stop:
04F9 B207       342            cpl start_stop_flag
04FB 80CB       343            sjmp LCD_PB_Done
04FD            344   
04FD            345   ;---------------------------------;
04FD            346   ; Send a BCD number to PuTTY      ;
04FD            347   ;---------------------------------;
                348   Send_BCD mac
                349   	push ar0
                350   	mov r0, %0
                351   	lcall ?Send_BCD
                352   	pop ar0
                353   endmac
04FD            354   
04FD            355   ?Send_BCD:
04FD C0E0       356            push acc
04FF            357            ; Write most significant digit
04FF E8         358            mov a, r0
0500 C4         359            swap a
0501 540F       360            anl a, #0fh
0503 4430       361            orl a, #30h
0505 120448     362            lcall putchar
0508            363            ; write least significant digit
0508 E8         364            mov a, r0
0509 540F       365            anl a, #0fh
050B 4430       366            orl a, #30h
050D 120448     367            lcall putchar
0510 D0E0       368            pop acc
0512 22         369            ret
0513            370   
0513            371   ; We can display a number any way we want.  In this case with
0513            372   ; four decimal places.
0513            373   Display_formated_BCD:
0513 C0E0       374            push acc
0515 7404       374            mov a, #4
0517 14         374            dec a
0518 12010D     374            lcall ?Set_Cursor_1 ; Select column and row
051B D0E0       374            pop acc ; display To
051D C000       375            push ar0
051F A83C       375            mov r0, bcd+4
0521 120112     375            lcall ?Display_BCD
0524 D000       375            pop ar0
0526 C000       376            push ar0
0528 A83B       376            mov r0, bcd+3
052A 120112     376            lcall ?Display_BCD
052D D000       376            pop ar0 ;this is just in case temperatures exceed 100C and we're in deg F
052F C000       377            push ar0
0531 A83A       377            mov r0, bcd+2
0533 120112     377            lcall ?Display_BCD
0536 D000       377            pop ar0
0538            378   
0538 C0E0       379            push acc
053A 740D       379            mov a, #13
053C 14         379            dec a
053D 12010D     379            lcall ?Set_Cursor_1 ; Select column and row
0540 D0E0       379            pop acc
0542 C083       380            push dph
0544 C082       380            push dpl
0546 C0E0       380            push acc
0548 900016     380            mov dptr, #22
054B 120100     380            lcall ?Send_Constant_String
054E D0E0       380            pop acc
0550 D082       380            pop dpl
0552 D083       380            pop dph ; display Tj=22
0554 22         381            ret
0555            382   
0555            383   
0555            384   ;-------------------------------------------------;
0555            385   ; Display all values and temperatures to the LCD  ;
0555            386   ;-------------------------------------------------;
0555            387   Display_Data:
0555 C2EF       388            clr ADCF
0557 D2EE       389            setb ADCS ;  ADC start trigger signal
0559 30EFFD     390       jnb ADCF, $ ; Wait for conversion complete
055C            391       
055C            392       ; Read the ADC result and store in [R1, R0]
055C E5C3       393       mov a, ADCRH   
055E C4         394       swap a
055F C0E0       395       push acc
0561 540F       396       anl a, #0x0f
0563 F9         397       mov R1, a
0564 D0E0       398       pop acc
0566 54F0       399       anl a, #0xf0
0568 45C2       400       orl a, ADCRL
056A F8         401       mov R0, A
056B            402       
056B            403       ; Convert to voltage
056B 8830       404            mov x+0, R0
056D 8931       405            mov x+1, R1
056F            406            ; Pad other bits with zero
056F 753200     407            mov x+2, #0
0572 753300     408            mov x+3, #0
0575            409            
0575            410            ;lcall div32 ; Get V_out
0575            411            ; ; Calculate Temp based on V_out
0575            412            ; Load_y(27300) ; The reference temp K
0575            413            ; lcall sub32 ; Get Temp*0.01
0575            414            ; ; Change Temp*0.01 to Temp
0575            415            ; Load_y(100)
0575            416            ; lcall mul32
0575            417   
0575 75347C     418            mov y+0, #low (50300 % 0x10000) 
0578 7535C4     418            mov y+1, #high(50300 % 0x10000) 
057B 753600     418            mov y+2, #low (50300 / 0x10000) 
057E 753700     418            mov y+3, #high(50300 / 0x10000)  ; VCC voltage measured (equals 4.99V)
0581 1202A2     419            lcall mul32 ;multiplying ADC * Vref
0584 7534FF     420            mov y+0, #low (4095 % 0x10000) 
0587 75350F     420            mov y+1, #high(4095 % 0x10000) 
058A 753600     420            mov y+2, #low (4095 / 0x10000) 
058D 753700     420            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
0590 12032F     421            lcall div32 ;now doing (ADC*Vref)/(4095)
0593            422            
0593 7534E8     423            mov y+0, #low (1000 % 0x10000) 
0596 753503     423            mov y+1, #high(1000 % 0x10000) 
0599 753600     423            mov y+2, #low (1000 / 0x10000) 
059C 753700     423            mov y+3, #high(1000 / 0x10000)  ; for converting volt to microvolt
059F 1202A2     424            lcall mul32 ;multiplying volts
05A2            425            
05A2 75340A     426            mov y+0, #low (10 % 0x10000) 
05A5 753500     426            mov y+1, #high(10 % 0x10000) 
05A8 753600     426            mov y+2, #low (10 / 0x10000) 
05AB 753700     426            mov y+3, #high(10 / 0x10000) 
05AE 1202A2     427            lcall mul32
05B1            428            
05B1            429            ;convert to temperature
05B1 7534CC     430            mov y+0, #low (23500 % 0x10000) 
05B4 75355B     430            mov y+1, #high(23500 % 0x10000) 
05B7 753600     430            mov y+2, #low (23500 / 0x10000) 
05BA 753700     430            mov y+3, #high(23500 / 0x10000)  ;divide by the gain 
05BD 12032F     431            lcall div32 
05C0 753429     432            mov y+0, #low (41 % 0x10000) 
05C3 753500     432            mov y+1, #high(41 % 0x10000) 
05C6 753600     432            mov y+2, #low (41 / 0x10000) 
05C9 753700     432            mov y+3, #high(41 / 0x10000) ;load y = 41
05CC 12032F     433            lcall div32 ;divide by 41
05CF            434            
05CF 753410     435            mov y+0, #low (10000 % 0x10000) 
05D2 753527     435            mov y+1, #high(10000 % 0x10000) 
05D5 753600     435            mov y+2, #low (10000 / 0x10000) 
05D8 753700     435            mov y+3, #high(10000 / 0x10000) 
05DB 1202A2     436            lcall mul32
05DE            437            
05DE 753460     438            mov y+0, #low (220000 % 0x10000) 
05E1 75355B     438            mov y+1, #high(220000 % 0x10000) 
05E4 753603     438            mov y+2, #low (220000 / 0x10000) 
05E7 753700     438            mov y+3, #high(220000 / 0x10000)  ;cold junction 19 deg C
05EA 1201ED     439            lcall add32
05ED            440   
05ED            441   ; Convert to BCD and display
05ED 120128     442            lcall hex2bcd
05F0 120513     443            lcall Display_formated_BCD
05F3            444            
05F3            445            ;send the BCD value to the MATLAB script
05F3 C000       446            push ar0
05F5 A83B       446            mov r0, bcd+3
05F7 1204FD     446            lcall ?Send_BCD
05FA D000       446            pop ar0
05FC C000       447            push ar0
05FE A83A       447            mov r0, bcd+2
0600 1204FD     447            lcall ?Send_BCD
0603 D000       447            pop ar0
0605 C000       448            push ar0
0607 A839       448            mov r0, bcd+1
0609 1204FD     448            lcall ?Send_BCD
060C D000       448            pop ar0
060E C000       449            push ar0
0610 A838       449            mov r0, bcd
0612 1204FD     449            lcall ?Send_BCD
0615 D000       449            pop ar0
0617 740D       450            mov a, #'\r'
0619 120448     451            lcall putchar
061C 740A       452            mov a, #'\n'
061E 120448     453            lcall putchar
0621            454            
0621            455            ; Wait 500 ms between conversions
0621 7AFA       456            mov R2, #250
0623 120460     457            lcall waitms
0626 7AFA       458            mov R2, #250
0628 120460     459            lcall waitms
062B            460   
062B 32         461            reti
062C            462   
062C            463   main:
062C 75817F     464            mov sp, #0x7f
062F 1203FE     465            lcall Init_All
0632 1200CD     466       lcall LCD_4BIT
0635 120398     467       lcall Timer0_Init
0638 1203BB     468       lcall Timer2_Init
063B D2AF       469       setb EA   ; Enable Global interrupts
063D            470       ; initial messages in LCD
063D C0E0       471            push acc
063F 7401       471            mov a, #1
0641 14         471            dec a
0642 12010D     471            lcall ?Set_Cursor_1 ; Select column and row
0645 D0E0       471            pop acc
0647 C083       472            push dph
0649 C082       472            push dpl
064B C0E0       472            push acc
064D 900003     472            mov dptr, #To_Message
0650 120100     472            lcall ?Send_Constant_String
0653 D0E0       472            pop acc
0655 D082       472            pop dpl
0657 D083       472            pop dph
0659 C0E0       473            push acc
065B 7401       473            mov a, #1
065D 14         473            dec a
065E 12010B     473            lcall ?Set_Cursor_2 ; Select column and row
0661 D0E0       473            pop acc
0663 C083       474            push dph
0665 C082       474            push dpl
0667 C0E0       474            push acc
0669 900014     474            mov dptr, #Time_temp_display
066C 120100     474            lcall ?Send_Constant_String
066F D0E0       474            pop acc
0671 D082       474            pop dpl
0673 D083       474            pop dph
0675            475            
0675 753F00     476            mov seconds, #0x00
0678 75458C     477            mov soak_temp, #0140 
067B 754460     478            mov soak_time, #0x60
067E 7543E6     479            mov reflow_temp, #0230
0681 754230     480            mov reflow_time, #0x30
0684 D2CA       481            setb TR2
0686            482       
0686            483   ;---------------------------------;
0686            484   ;                FSM     funtion                               ;
0686            485   ;---------------------------------;
0686            486   FSM:
0686 E54B       487       mov a, FSM_state
0688            488   FSM_state0:
0688 B4000F     489       cjne a, #0, FSM_state1
068B 754700     490       mov pwm, #0 ; power variable
068E            491   
068E 300706     492       jnb start_stop_flag, FSM_state0_done
0691 753F00     493       mov seconds, #0     ; set time to 0
0694 754B01     494       mov FSM_state, #1   ; set FSM_state to 1, next state is state1
0697            495   FSM_state0_done:
0697 020686     496       ljmp FSM    ;jump back to FSM and reload FSM_state to a
069A            497   
069A            498   FSM_state1:
069A B40154     499       cjne a, #1, FSM_state2
069D 754764     500       mov pwm, #100
06A0 C0E0       501            push acc
06A2 7401       501            mov a, #1
06A4 14         501            dec a
06A5 12010B     501            lcall ?Set_Cursor_2 ; Select column and row
06A8 D0E0       501            pop acc
06AA C083       502            push dph
06AC C082       502            push dpl
06AE C0E0       502            push acc
06B0 900025     502            mov dptr, #Ramp_to_soak
06B3 120100     502            lcall ?Send_Constant_String
06B6 D0E0       502            pop acc
06B8 D082       502            pop dpl
06BA D083       502            pop dph
06BC C3         503       clr c
06BD 300725     504       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
06C0 7460       505       mov a, #0x60
06C2 953F       506       subb a, seconds
06C4 4013       507       jc abort
06C6            508   continue:
06C6 C3         509       clr c   ; ! i don't know what is c
06C7 E545       510       mov a, soak_temp    ; set a to soak temp
06C9 853848     511            mov temp, bcd
06CC 9548       512       subb a, temp    ; temp is our currect temp
06CE 5006       513       jnc FSM_state1_done
06D0 753F00     514       mov seconds, #0     ; set time to 0
06D3 754B02     515       mov FSM_state, #2
06D6            516   FSM_state1_done:
06D6 020686     517       ljmp FSM
06D9            518   abort:
06D9 7432       519       mov a, #50  ; set a to 50 degree
06DB 853848     520            mov temp, bcd
06DE 9548       521       subb a, temp
06E0 40E4       522       jc continue     ; if temp is larger then 50 degree, go back to continue
06E2 754B00     523       mov FSM_state, #0   ; abort the FSM
06E5            524   
06E5            525   stop_state:
06E5 C2CA       526       clr TR2
06E7 300705     527       jnb start_stop_flag, stop
06EA D2CA       528            setb TR2
06EC 020686     529            ljmp FSM
06EF            530   
06EF            531   stop:
06EF 80F4       532       sjmp stop_state
06F1            533   
06F1            534   FSM_state2:
06F1 B40232     535       cjne a, #2, FSM_state3
06F4 754714     536       mov pwm, #20
06F7 E544       537       mov a, soak_time    ; set a to soak time
06F9 C0E0       538            push acc
06FB 7401       538            mov a, #1
06FD 14         538            dec a
06FE 12010B     538            lcall ?Set_Cursor_2 ; Select column and row
0701 D0E0       538            pop acc
0703 C083       539            push dph
0705 C082       539            push dpl
0707 C0E0       539            push acc
0709 900036     539            mov dptr, #Soak_display
070C 120100     539            lcall ?Send_Constant_String
070F D0E0       539            pop acc
0711 D082       539            pop dpl
0713 D083       539            pop dph
0715 C3         540       clr c   ; ! i don't know what is c 
0716 3007CC     541       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
0719 953F       542       subb a, seconds    ; temp is our currect sec
071B 5006       543       jnc FSM_state2_done
071D 753F00     544       mov seconds, #0     ; set time to 0
0720 754B03     545       mov FSM_state, #3
0723            546   FSM_state2_done:
0723 020686     547       ljmp FSM
0726            548   
0726            549   FSM_state3:
0726 B4033B     550       cjne a, #3, FSM_state4
0729 754764     551       mov pwm, #100
072C E543       552       mov a, reflow_temp    ; set a to reflow temp
072E C0E0       553            push acc
0730 7401       553            mov a, #1
0732 14         553            dec a
0733 12010B     553            lcall ?Set_Cursor_2 ; Select column and row
0736 D0E0       553            pop acc
0738 C083       554            push dph
073A C082       554            push dpl
073C C0E0       554            push acc
073E 900044     554            mov dptr, #Ramp_to_peak
0741 120100     554            lcall ?Send_Constant_String
0744 D0E0       554            pop acc
0746 D082       554            pop dpl
0748 D083       554            pop dph
074A C3         555       clr c   ; ! i don't know what is c 
074B 300797     556       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
074E 853848     557            mov temp, bcd
0751 9548       558       subb a, temp    ; temp is our currect temp
0753 5006       559       jnc FSM_state3_done
0755 753F00     560       mov seconds, #0     ; set time to 0
0758 754B04     561       mov FSM_state, #4
075B            562   FSM_state3_done:
075B 020686     563       ljmp FSM
075E            564            
075E            565   intermediate_state_0:
075E 020688     566            ljmp FSM_state0
0761            567   
0761            568   intermediate_stop_jump:
0761 0206E5     569            ljmp stop_state
0764            570   
0764            571   FSM_state4:
0764 B40432     572       cjne a, #4, FSM_state5
0767 754714     573       mov pwm, #20
076A E542       574       mov a, reflow_time    ; set a to reflow time
076C C0E0       575            push acc
076E 7401       575            mov a, #1
0770 14         575            dec a
0771 12010B     575            lcall ?Set_Cursor_2 ; Select column and row
0774 D0E0       575            pop acc
0776 C083       576            push dph
0778 C082       576            push dpl
077A C0E0       576            push acc
077C 900055     576            mov dptr, #Reflow_display
077F 120100     576            lcall ?Send_Constant_String
0782 D0E0       576            pop acc
0784 D082       576            pop dpl
0786 D083       576            pop dph
0788 C3         577       clr c   ; ! i don't know what is c 
0789 3007D5     578       jnb start_stop_flag, intermediate_stop_jump; checks the flag if 0, then means stop was pressed, if 1 keep on going
078C 953F       579       subb a, seconds    ; temp is our currect sec
078E 5006       580       jnc FSM_state4_done
0790 753F00     581       mov seconds, #0     ; set time to 0
0793 754B05     582       mov FSM_state, #5
0796            583   FSM_state4_done:
0796 020686     584       ljmp FSM
0799            585   
0799            586   FSM_state5:
0799 B405C2     587       cjne a, #5, intermediate_state_0
079C 754700     588       mov pwm, #0
079F 743C       589       mov a, #60    ; set a to 60
07A1 C0E0       590            push acc
07A3 7401       590            mov a, #1
07A5 14         590            dec a
07A6 12010B     590            lcall ?Set_Cursor_2 ; Select column and row
07A9 D0E0       590            pop acc
07AB C083       591            push dph
07AD C082       591            push dpl
07AF C0E0       591            push acc
07B1 900064     591            mov dptr, #Cooling_display
07B4 120100     591            lcall ?Send_Constant_String
07B7 D0E0       591            pop acc
07B9 D082       591            pop dpl
07BB D083       591            pop dph
07BD C3         592       clr c   ; ! i don't know what is c
07BE 3007A0     593       jnb start_stop_flag, intermediate_stop_jump ; checks the flag if 0, then means stop was pressed, if 1 keep on going 
07C1 853848     594       mov temp, bcd
07C4 9548       595            subb a, temp    ; temp is our currect temp, need to be edit
07C6 5006       596       jnc FSM_state5_done
07C8 753F00     597       mov seconds, #0     ; set time to 0
07CB 754B00     598       mov FSM_state, #0
07CE            599   FSM_state5_done:
07CE 020686     600       ljmp FSM
07D1            601   EN
