                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             21   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             22   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             23   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             25   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             26   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             27   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             28   
0000             29   ;---------------------------------;
0000             30   ; Define any buttons & pins here  ;
0000             31   ;---------------------------------;
0000             32   ;!!!!!arbiturary value for now
0000             33   SOUND_OUT   equ p1.7 ; speaker pin
0000             34   ; Output
0000             35   PWM_OUT    EQU P1.0 ; Logic 1=oven on
0000             36   ;---------------------------------------------
0000             37   ORG 0x0000
0000 02064D      38            ljmp main
0003             39   
0003             40   ;---------------------------------;
0003             41   ; Define any constant string here ;
0003             42   ;---------------------------------;
0003             43   ;                          1234567890123456    <- This helps determine the location of the counter
0003 546F3D78    44   To_Message:        db 'To=xxxC Tj= xxC ', 0
     78784320
     546A3D20
     78784320
     00
0014 73787878    45   Time_temp_display:db 'sxxx,xx rxxx,xx ', 0 ; soak temp,time reflow temp,time
     2C787820
     72787878
     2C787820
     00
0025 52616D70    46   Ramp_to_soak:      db 'RampToSoak s=xxx', 0 ; state 1 display
     546F536F
     616B2073
     3D787878
     00
0036 536F616B    47   Soak_display:      db 'Soak               s=xxx', 0 ; state 2 display
     20090920
     733D7878
     7800
0044 52616D70    48   Ramp_to_peak:      db 'RampToPeak s=xxx', 0 ; state 3 display
     546F5065
     616B2073
     3D787878
     00
0055 5265666C    49   Reflow_display:   db 'Reflow      s=xxx', 0 ; state 4 display
     6F772009
     20733D78
     787800
0064 436F6F6C    50   Cooling_display:  db 'Cooling     s=xxx', 0 ; state 5 display
     696E6720
     0920733D
     78787800
0074 4300        51   celcius:                   db 'C', 0
0076 4600        52   fahren:                    db 'F', 0
0078             53   ;---------------------------------------------
0078             54   cseg
0078             55   
0078             56   LCD_RS equ P1.3
0078             57   LCD_E  equ P1.4
0078             58   LCD_D4 equ P0.0
0078             59   LCD_D5 equ P0.1
0078             60   LCD_D6 equ P0.2
0078             61   LCD_D7 equ P0.3
0078             62   
                 64   	$LIST
012C             66   
012C             67   ;---------------------------------;
012C             68   ; Define variables here           ;
012C             69   ;---------------------------------;
012C             70   ; These register definitions needed by 'math32.inc'
0030             71   DSEG at 30H
0030             72   x:   ds 4
0034             73   y:   ds 4
0038             74   bcd: ds 5   ;temperature variable for reading
003D             75   Count1ms:     ds 2 ; Used to determine when one second has passed
003F             76   seconds: ds 1
0040             77   VLED_ADC: ds 2
0042             78   reflow_time: ds 1 ; time parameter for reflow    
0043             79   reflow_temp: ds 1 ; temp parameter for reflow
0044             80   soak_time: ds 1 ; time parameter for soak
0045             81   soak_temp: ds 1 ; temp parameter for soak
0046             82   pwm_counter: ds 1 ; power counter
0047             83   pwm: ds 1 ; variable to count the power percentage
0048             84   temp: ds 3
004B             85   FSM_state: ds 1
004C             86   ;---------------------------------------------
004C             87   
004C             88   ;---------------------------------;
004C             89   ; Define flags here               ;
004C             90   ;---------------------------------;
0000             91   BSEG
0000             92   mf: dbit 1
0001             93   s_flag: dbit 1 ; Set to one in the ISR every time 1000 ms had passed
0002             94   PB0: dbit 1      ; start/stop
0003             95   PB1: dbit 1      ; increment reflow time
0004             96   PB2: dbit 1      ; increment reflow temp
0005             97   PB3: dbit 1      ; increment soak time
0006             98   PB4: dbit 1      ; increment soak temp
0007             99   start_stop_flag: dbit 1 ; Set to one if button is pressed to start, press again to stop
0008            100   ;---------------------------------------------
0008            101   
                546   $LIST
                103   $LIST
039C            105   
039C            106   ;---------------------------------;
039C            107   ; Routine to initialize the ISR   ;
039C            108   ; for timer 0                     ;
039C            109   ;---------------------------------;
039C            110   Timer0_Init:
039C 438E08     111            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
039F E589       112            mov a, TMOD
03A1 54F0       113            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03A3 4401       114            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03A5 F589       115            mov TMOD, a
03A7 758CF0     116            mov TH0, #high(TIMER0_RELOAD)
03AA 758A2C     117            mov TL0, #low(TIMER0_RELOAD)
03AD            118            ; Enable the timer and interrupts
03AD D2A9       119       setb ET0  ; Enable timer 0 interrupt
03AF D28C       120       setb TR0  ; Start timer 0
03B1 22         121            ret
03B2            122   
03B2            123   ;---------------------------------;
03B2            124   ; ISR for timer 0.  Set to execute;
03B2            125   ; every 1/4096Hz to generate a    ;
03B2            126   ; 2048 Hz wave at pin SOUND_OUT   ;
03B2            127   ;---------------------------------;
03B2            128   Timer0_ISR:
03B2            129            ;clr TF0  ; According to the data sheet this is done for us already.
03B2            130            ; Timer 0 doesn't have 16-bit auto-reload, so
03B2 C28C       131            clr TR0
03B4 758CF0     132            mov TH0, #high(TIMER0_RELOAD)
03B7 758A2C     133            mov TL0, #low(TIMER0_RELOAD)
03BA D28C       134            setb TR0
03BC B297       135            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
03BE 32         136            reti
03BF            137   
03BF            138   ;---------------------------------;
03BF            139   ; Routine to initialize the ISR   ;
03BF            140   ; for timer 2                     ;
03BF            141   ;---------------------------------;
03BF            142   Timer2_Init:
03BF 75C800     143            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
03C2 75CDBF     144            mov TH2, #high(TIMER2_RELOAD)
03C5 75CC28     145            mov TL2, #low(TIMER2_RELOAD)
03C8            146            ; Set the reload value
03C8 43C980     147            orl T2MOD, #0x80 ; Enable timer 2 autoreload
03CB 75CBBF     148            mov RCMP2H, #high(TIMER2_RELOAD)
03CE 75CA28     149            mov RCMP2L, #low(TIMER2_RELOAD)
03D1            150            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
03D1 E4         151            clr a
03D2 F53D       152            mov Count1ms+0, a
03D4 F53E       153            mov Count1ms+1, a
03D6 754700     154            mov pwm, #0
03D9            155            ; Enable the timer and interrupts
03D9 439B80     156            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
03DC D2CA       157       setb TR2  ; Enable timer 2
03DE 22         158            ret
03DF            159   
03DF            160   ;---------------------------------;
03DF            161   ; ISR for timer 2 ;
03DF            162   ;---------------------------------;
03DF            163   Timer2_ISR:
03DF C2CF       164            clr TF2 ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR. It is bit addressable.
03E1 B284       165            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
03E3            166                    
03E3            167            ; The two registers used in the ISR must be saved in the stack
03E3 C0D0       168            push psw
03E5 C0E0       169            push acc
03E7 0546       170            inc pwm_counter
03E9 C3         171            clr c
03EA E547       172            mov a, pwm
03EC 9546       173            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
03EE B3         174            cpl c
03EF 9290       175            mov PWM_OUT, c
03F1 E546       176            mov a, pwm_counter
03F3 B46407     177            cjne a, #100, Timer2_ISR_done
03F6 754600     178            mov pwm_counter, #0
03F9 053F       179            inc seconds ; It is super easy to keep a seconds count here
03FB D201       180            setb s_flag
03FD            181   
03FD            182   Timer2_ISR_done:
03FD D0E0       183            pop acc
03FF D0D0       184            pop psw
0401 32         185            reti
0402            186   
0402            187   ;---------------------------------;
0402            188   ; Temperature senseor function    ;
0402            189   ;---------------------------------;
0402            190   Init_All:
0402            191            ; Configure all the pins for biderectional I/O
0402 75AC00     192            mov     P3M1, #0x00
0405 75AD00     193            mov     P3M2, #0x00
0408 75B300     194            mov     P1M1, #0x00
040B 75B400     195            mov     P1M2, #0x00
040E 75B100     196            mov     P0M1, #0x00
0411 75B200     197            mov     P0M2, #0x00
0414            198            
0414 438E10     199            orl     CKCON, #0x10 ; CLK is the input for timer 1
0417 438780     200            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
041A 759852     201            mov     SCON, #0x52
041D 53C4DF     202            anl     T3CON, #0b11011111
0420 53890F     203            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0423 438920     204            orl     TMOD, #0x20 ; Timer 1 Mode 2
0426 758DF7     205            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
0429 D28E       206            setb TR1
042B            207            
042B            208            ; Using timer 0 for delay functions.  Initialize here:
042B C28C       209            clr     TR0 ; Stop timer 0
042D 438E08     210            orl     CKCON,#0x08 ; CLK is the input for timer 0
0430 5389F0     211            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0433 438901     212            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0436            213            
0436            214            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
0436 43B382     215            orl     P1M1, #0b10000010
0439 53B47D     216            anl     P1M2, #0b01111101
043C            217            
043C            218            ; Initialize and start the ADC:
043C 53E8F0     219            anl ADCCON0, #0xF0
043F 43E807     220            orl ADCCON0, #0x07 ; Select channel 7
0442            221            ; AINDIDS select if some pins are analog inputs or digital I/O:
0442 75F600     222            mov AINDIDS, #0x00 ; Disable all analog inputs
0445 43F681     223            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
0448 43E101     224            orl ADCCON1, #0x01 ; Enable ADC
044B            225            
044B 22         226            ret
044C            227            
044C            228   ; Send a character using the serial port
044C            229   putchar:
044C 3099FD     230       jnb TI, putchar
044F C299       231       clr TI
0451 F599       232       mov SBUF, a
0453 22         233       ret
0454            234   
0454            235   wait_1ms:
0454 C28C       236            clr     TR0 ; Stop timer 0
0456 C28D       237            clr     TF0 ; Clear overflow flag
0458 758CBF     238            mov     TH0, #high(TIMER0_RELOAD_1MS)
045B 758A28     239            mov     TL0,#low(TIMER0_RELOAD_1MS)
045E D28C       240            setb TR0
0460 308DFD     241            jnb     TF0, $ ; Wait for overflow
0463 22         242            ret
0464            243   
0464            244   ; Wait the number of miliseconds in R2
0464            245   waitms:
0464 120454     246            lcall wait_1ms
0467 DAFB       247            djnz R2, waitms
0469 22         248            ret
046A            249   
046A            250   ;---------------------------------;
046A            251   ;         5_pushbuttons function               ;
046A            252   ;---------------------------------;
046A            253   LCD_PB:
046A            254            ; Set variables to 1: 'no push button pressed'
046A D202       255            setb PB0
046C D203       256            setb PB1
046E D204       257            setb PB2
0470 D205       258            setb PB3
0472 D206       259            setb PB4
0474            260            ; The input pin used to check set to '1'
0474 D295       261            setb P1.5
0476            262            
0476            263            ; Check if any push button is pressed
0476 C280       264            clr P0.0
0478 C281       265            clr P0.1
047A C282       266            clr P0.2
047C C283       267            clr P0.3
047E C293       268            clr P1.3
0480 209549     269            jb P1.5, LCD_PB_Done
0483            270   
0483            271            ; Debounce
0483 7A32       272            mov R2, #50
0485 120464     273            lcall waitms
0488 209541     274            jb P1.5, LCD_PB_Done
048B            275   
048B            276            ; Set the LCD data pins to logic 1
048B D280       277            setb P0.0
048D D281       278            setb P0.1
048F D282       279            setb P0.2
0491 D283       280            setb P0.3
0493 D293       281            setb P1.3
0495            282            
0495            283            ; Check the push buttons one by one
0495 C293       284            clr P1.3
0497 A295       285            mov c, P1.5
0499 9206       286            mov PB4, c
049B D293       287            setb P1.3
049D 30062D     288            jnb PB4,increment_soak_temp
04A0            289   
04A0 C280       290            clr P0.0
04A2 A295       291            mov c, P1.5
04A4 9205       292            mov PB3, c
04A6 D280       293            setb P0.0
04A8 30052E     294            jnb PB3, increment_soak_time
04AB            295            
04AB C281       296            clr P0.1
04AD A295       297            mov c, P1.5
04AF 9204       298            mov PB2, c
04B1 D281       299            setb P0.1
04B3 30042F     300            jnb PB2, increment_reflow_temp
04B6            301            
04B6 C282       302            clr P0.2
04B8 A295       303            mov c, P1.5
04BA 9203       304            mov PB1, c
04BC D282       305            setb P0.2
04BE 300330     306            jnb PB1, increment_reflow_time
04C1            307            
04C1 C283       308            clr P0.3
04C3 A295       309            mov c, P1.5
04C5 9202       310            mov PB0, c
04C7 D283       311            setb P0.3
04C9 300231     312            jnb PB0, start_stop
04CC            313   
04CC            314   
04CC            315   LCD_PB_Done:             
04CC 22         316            ret
04CD            317   
04CD            318   increment_soak_temp:
04CD 0545       319            inc soak_temp
04CF E545       320            mov a, soak_temp
04D1 B4F0F8     321            cjne a, #240, LCD_PB_Done
04D4 754500     322            mov soak_temp, #0x00
04D7 80F3       323            sjmp LCD_PB_Done
04D9            324   increment_soak_time:
04D9 0544       325            inc soak_time
04DB E544       326            mov a, soak_time
04DD B478EC     327            cjne a, #120, LCD_PB_Done
04E0 754400     328            mov soak_time, #0x00
04E3 80E7       329            sjmp LCD_PB_Done
04E5            330   increment_reflow_temp: 
04E5 0543       331            inc reflow_temp
04E7 E543       332            mov a, reflow_temp
04E9 B4F0E0     333            cjne a, #240, LCD_PB_Done
04EC 754300     334            mov reflow_temp, #0x00
04EF 80DB       335            sjmp LCD_PB_Done
04F1            336   increment_reflow_time:
04F1 0542       337            inc reflow_time
04F3 E542       338            mov a, reflow_time
04F5 B44BD4     339            cjne a, #75, LCD_PB_Done
04F8 754200     340            mov reflow_time, #0x00
04FB 80CF       341            sjmp LCD_PB_Done
04FD            342   
04FD            343   start_stop:
04FD B207       344            cpl start_stop_flag
04FF 80CB       345            sjmp LCD_PB_Done
0501            346   
0501            347   ;---------------------------------;
0501            348   ; Send a BCD number to PuTTY      ;
0501            349   ;---------------------------------;
                350   Send_BCD mac
                351   	push ar0
                352   	mov r0, %0
                353   	lcall ?Send_BCD
                354   	pop ar0
                355   endmac
0501            356   
0501            357   ?Send_BCD:
0501 C0E0       358            push acc
0503            359            ; Write most significant digit
0503 E8         360            mov a, r0
0504 C4         361            swap a
0505 540F       362            anl a, #0fh
0507 4430       363            orl a, #30h
0509 12044C     364            lcall putchar
050C            365            ; write least significant digit
050C E8         366            mov a, r0
050D 540F       367            anl a, #0fh
050F 4430       368            orl a, #30h
0511 12044C     369            lcall putchar
0514 D0E0       370            pop acc
0516 22         371            ret
0517            372   
0517            373   ; We can display a number any way we want.  In this case with
0517            374   ; four decimal places.
0517            375   Display_formated_BCD:
0517 C0E0       376            push acc
0519 7405       376            mov a, #5
051B 14         376            dec a
051C 12010F     376            lcall ?Set_Cursor_2 ; Select column and row
051F D0E0       376            pop acc
0521 C000       377            push ar0
0523 A83C       377            mov r0, bcd+4
0525 120116     377            lcall ?Display_BCD
0528 D000       377            pop ar0
052A C000       378            push ar0
052C A83B       378            mov r0, bcd+3
052E 120116     378            lcall ?Display_BCD
0531 D000       378            pop ar0 ;this is just in case temperatures exceed 100C and we're in deg F
0533 C000       379            push ar0
0535 A83A       379            mov r0, bcd+2
0537 120116     379            lcall ?Display_BCD
053A D000       379            pop ar0
053C C0E0       380            push acc
053E 742E       380            mov a, #'.'
0540 1200C7     380            lcall ?WriteData
0543 D0E0       380            pop acc
0545 C000       381            push ar0
0547 A839       381            mov r0, bcd+1
0549 120116     381            lcall ?Display_BCD
054C D000       381            pop ar0
054E C000       382            push ar0
0550 A838       382            mov r0, bcd+0
0552 120116     382            lcall ?Display_BCD
0555 D000       382            pop ar0
0557 C0E0       383            push acc
0559 740D       383            mov a, #13
055B 14         383            dec a
055C 120111     383            lcall ?Set_Cursor_1 ; Select column and row
055F D0E0       383            pop acc
0561 C083       384            push dph
0563 C082       384            push dpl
0565 C0E0       384            push acc
0567 900074     384            mov dptr, #celcius
056A 120104     384            lcall ?Send_Constant_String
056D D0E0       384            pop acc
056F D082       384            pop dpl
0571 D083       384            pop dph
0573 8000       385            sjmp printcel
0575            386   
0575            387   printcel:
0575 22         388            ret
0576            389   
0576            390   
0576            391   ;-------------------------------------------------;
0576            392   ; Display all values and temperatures to the LCD  ;
0576            393   ;-------------------------------------------------;
0576            394   Display_Data:
0576 C2EF       395            clr ADCF
0578 D2EE       396            setb ADCS ;  ADC start trigger signal
057A 30EFFD     397       jnb ADCF, $ ; Wait for conversion complete
057D            398       
057D            399       ; Read the ADC result and store in [R1, R0]
057D E5C3       400       mov a, ADCRH   
057F C4         401       swap a
0580 C0E0       402       push acc
0582 540F       403       anl a, #0x0f
0584 F9         404       mov R1, a
0585 D0E0       405       pop acc
0587 54F0       406       anl a, #0xf0
0589 45C2       407       orl a, ADCRL
058B F8         408       mov R0, A
058C            409       
058C            410       ; Convert to voltage
058C 8830       411            mov x+0, R0
058E 8931       412            mov x+1, R1
0590            413            ; Pad other bits with zero
0590 753200     414            mov x+2, #0
0593 753300     415            mov x+3, #0
0596            416            
0596            417            ;lcall div32 ; Get V_out
0596            418            ; ; Calculate Temp based on V_out
0596            419            ; Load_y(27300) ; The reference temp K
0596            420            ; lcall sub32 ; Get Temp*0.01
0596            421            ; ; Change Temp*0.01 to Temp
0596            422            ; Load_y(100)
0596            423            ; lcall mul32
0596            424   
0596 75347C     425            mov y+0, #low (50300 % 0x10000) 
0599 7535C4     425            mov y+1, #high(50300 % 0x10000) 
059C 753600     425            mov y+2, #low (50300 / 0x10000) 
059F 753700     425            mov y+3, #high(50300 / 0x10000)  ; VCC voltage measured (equals 4.99V)
05A2 1202A6     426            lcall mul32 ;multiplying ADC * Vref
05A5 7534FF     427            mov y+0, #low (4095 % 0x10000) 
05A8 75350F     427            mov y+1, #high(4095 % 0x10000) 
05AB 753600     427            mov y+2, #low (4095 / 0x10000) 
05AE 753700     427            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
05B1 120333     428            lcall div32 ;now doing (ADC*Vref)/(4095)
05B4            429            
05B4 7534E8     430            mov y+0, #low (1000 % 0x10000) 
05B7 753503     430            mov y+1, #high(1000 % 0x10000) 
05BA 753600     430            mov y+2, #low (1000 / 0x10000) 
05BD 753700     430            mov y+3, #high(1000 / 0x10000)  ; for converting volt to microvolt
05C0 1202A6     431            lcall mul32 ;multiplying volts
05C3            432            
05C3 75340A     433            mov y+0, #low (10 % 0x10000) 
05C6 753500     433            mov y+1, #high(10 % 0x10000) 
05C9 753600     433            mov y+2, #low (10 / 0x10000) 
05CC 753700     433            mov y+3, #high(10 / 0x10000) 
05CF 1202A6     434            lcall mul32
05D2            435            
05D2            436            ;convert to temperature
05D2 7534CC     437            mov y+0, #low (23500 % 0x10000) 
05D5 75355B     437            mov y+1, #high(23500 % 0x10000) 
05D8 753600     437            mov y+2, #low (23500 / 0x10000) 
05DB 753700     437            mov y+3, #high(23500 / 0x10000)  ;divide by the gain 
05DE 120333     438            lcall div32 
05E1 753429     439            mov y+0, #low (41 % 0x10000) 
05E4 753500     439            mov y+1, #high(41 % 0x10000) 
05E7 753600     439            mov y+2, #low (41 / 0x10000) 
05EA 753700     439            mov y+3, #high(41 / 0x10000) ;load y = 41
05ED 120333     440            lcall div32 ;divide by 41
05F0            441            
05F0 753410     442            mov y+0, #low (10000 % 0x10000) 
05F3 753527     442            mov y+1, #high(10000 % 0x10000) 
05F6 753600     442            mov y+2, #low (10000 / 0x10000) 
05F9 753700     442            mov y+3, #high(10000 / 0x10000) 
05FC 1202A6     443            lcall mul32
05FF            444            
05FF 753460     445            mov y+0, #low (220000 % 0x10000) 
0602 75355B     445            mov y+1, #high(220000 % 0x10000) 
0605 753603     445            mov y+2, #low (220000 / 0x10000) 
0608 753700     445            mov y+3, #high(220000 / 0x10000)  ;cold junction 19 deg C
060B 1201F1     446            lcall add32
060E            447   
060E            448   ; Convert to BCD and display
060E            449   celc:
060E 12012C     450            lcall hex2bcd
0611 120517     451            lcall Display_formated_BCD
0614            452            
0614            453            ;send the BCD value to the MATLAB script
0614 C000       454            push ar0
0616 A83B       454            mov r0, bcd+3
0618 120501     454            lcall ?Send_BCD
061B D000       454            pop ar0
061D C000       455            push ar0
061F A83A       455            mov r0, bcd+2
0621 120501     455            lcall ?Send_BCD
0624 D000       455            pop ar0
0626 C000       456            push ar0
0628 A839       456            mov r0, bcd+1
062A 120501     456            lcall ?Send_BCD
062D D000       456            pop ar0
062F C000       457            push ar0
0631 A838       457            mov r0, bcd
0633 120501     457            lcall ?Send_BCD
0636 D000       457            pop ar0
0638 740D       458            mov a, #'\r'
063A 12044C     459            lcall putchar
063D 740A       460            mov a, #'\n'
063F 12044C     461            lcall putchar
0642            462            
0642            463            ; Wait 500 ms between conversions
0642 7AFA       464            mov R2, #250
0644 120464     465            lcall waitms
0647 7AFA       466            mov R2, #250
0649 120464     467            lcall waitms
064C            468   
064C 32         469            reti
064D            470   
064D            471   main:
064D 75817F     472            mov sp, #0x7f
0650 120402     473            lcall Init_All
0653 1200D1     474       lcall LCD_4BIT
0656 12039C     475       lcall Timer0_Init
0659 1203BF     476       lcall Timer2_Init
065C D2AF       477       setb EA   ; Enable Global interrupts
065E            478       ; initial messages in LCD
065E C0E0       479            push acc
0660 7401       479            mov a, #1
0662 14         479            dec a
0663 120111     479            lcall ?Set_Cursor_1 ; Select column and row
0666 D0E0       479            pop acc
0668 C083       480            push dph
066A C082       480            push dpl
066C C0E0       480            push acc
066E 900003     480            mov dptr, #To_Message
0671 120104     480            lcall ?Send_Constant_String
0674 D0E0       480            pop acc
0676 D082       480            pop dpl
0678 D083       480            pop dph
067A C0E0       481            push acc
067C 7401       481            mov a, #1
067E 14         481            dec a
067F 12010F     481            lcall ?Set_Cursor_2 ; Select column and row
0682 D0E0       481            pop acc
0684 C083       482            push dph
0686 C082       482            push dpl
0688 C0E0       482            push acc
068A 900014     482            mov dptr, #Time_temp_display
068D 120104     482            lcall ?Send_Constant_String
0690 D0E0       482            pop acc
0692 D082       482            pop dpl
0694 D083       482            pop dph
0696            483            
0696 753F00     484            mov seconds, #0x00
0699 75458C     485            mov soak_temp, #0140 
069C 754460     486            mov soak_time, #0x60
069F 7543E6     487            mov reflow_temp, #0230
06A2 754230     488            mov reflow_time, #0x30
06A5 D2CA       489            setb TR2
06A7            490       
06A7            491   ;---------------------------------;
06A7            492   ;                FSM     funtion                               ;
06A7            493   ;---------------------------------;
06A7            494   FSM:
06A7 E54B       495       mov a, FSM_state
06A9            496   FSM_state0:
06A9 B4000F     497       cjne a, #0, FSM_state1
06AC 754700     498       mov pwm, #0 ; power variable
06AF            499   
06AF 300706     500       jnb start_stop_flag, FSM_state0_done
06B2 753F00     501       mov seconds, #0     ; set time to 0
06B5 754B01     502       mov FSM_state, #1   ; set FSM_state to 1, next state is state1
06B8            503   FSM_state0_done:
06B8 0206A7     504       ljmp FSM    ;jump back to FSM and reload FSM_state to a
06BB            505   
06BB            506   FSM_state1:
06BB B4014E     507       cjne a, #1, FSM_state2
06BE 754764     508       mov pwm, #100
06C1 C0E0       509            push acc
06C3 7401       509            mov a, #1
06C5 14         509            dec a
06C6 12010F     509            lcall ?Set_Cursor_2 ; Select column and row
06C9 D0E0       509            pop acc
06CB C083       510            push dph
06CD C082       510            push dpl
06CF C0E0       510            push acc
06D1 900025     510            mov dptr, #Ramp_to_soak
06D4 120104     510            lcall ?Send_Constant_String
06D7 D0E0       510            pop acc
06D9 D082       510            pop dpl
06DB D083       510            pop dph
06DD C3         511       clr c
06DE 30071F     512       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
06E1 7460       513       mov a, #0x60
06E3 953F       514       subb a, seconds
06E5 4010       515       jc abort
06E7            516   continue:
06E7 C3         517       clr c   ; ! i don't know what is c
06E8 E545       518       mov a, soak_temp    ; set a to soak temp
06EA 9548       519       subb a, temp    ; temp is our currect temp
06EC 5006       520       jnc FSM_state1_done
06EE 753F00     521       mov seconds, #0     ; set time to 0
06F1 754B02     522       mov FSM_state, #2
06F4            523   FSM_state1_done:
06F4 0206A7     524       ljmp FSM
06F7            525   abort:
06F7 7432       526       mov a, #50  ; set a to 50 degree
06F9 9548       527       subb a, temp
06FB 40EA       528       jc continue     ; if temp is larger then 50 degree, go back to continue
06FD 754B00     529       mov FSM_state, #0   ; abort the FSM
0700            530   
0700            531   stop_state:
0700 C2CA       532       clr TR2
0702 300705     533       jnb start_stop_flag, stop
0705 D2CA       534            setb TR2
0707 0206A7     535            ljmp FSM
070A            536   
070A            537   stop:
070A 80F4       538       sjmp stop_state
070C            539   
070C            540   FSM_state2:
070C B40232     541       cjne a, #2, FSM_state3
070F 754714     542       mov pwm, #20
0712 E544       543       mov a, soak_time    ; set a to soak time
0714 C0E0       544            push acc
0716 7401       544            mov a, #1
0718 14         544            dec a
0719 12010F     544            lcall ?Set_Cursor_2 ; Select column and row
071C D0E0       544            pop acc
071E C083       545            push dph
0720 C082       545            push dpl
0722 C0E0       545            push acc
0724 900036     545            mov dptr, #Soak_display
0727 120104     545            lcall ?Send_Constant_String
072A D0E0       545            pop acc
072C D082       545            pop dpl
072E D083       545            pop dph
0730 C3         546       clr c   ; ! i don't know what is c 
0731 3007CC     547       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
0734 953F       548       subb a, seconds    ; temp is our currect sec
0736 5006       549       jnc FSM_state2_done
0738 753F00     550       mov seconds, #0     ; set time to 0
073B 754B03     551       mov FSM_state, #3
073E            552   FSM_state2_done:
073E 0206A7     553       ljmp FSM
0741            554   
0741            555   FSM_state3:
0741 B40338     556       cjne a, #3, FSM_state4
0744 754764     557       mov pwm, #100
0747 E543       558       mov a, reflow_temp    ; set a to reflow temp
0749 C0E0       559            push acc
074B 7401       559            mov a, #1
074D 14         559            dec a
074E 12010F     559            lcall ?Set_Cursor_2 ; Select column and row
0751 D0E0       559            pop acc
0753 C083       560            push dph
0755 C082       560            push dpl
0757 C0E0       560            push acc
0759 900044     560            mov dptr, #Ramp_to_peak
075C 120104     560            lcall ?Send_Constant_String
075F D0E0       560            pop acc
0761 D082       560            pop dpl
0763 D083       560            pop dph
0765 C3         561       clr c   ; ! i don't know what is c 
0766 300797     562       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
0769 9548       563       subb a, temp    ; temp is our currect temp
076B 5006       564       jnc FSM_state3_done
076D 753F00     565       mov seconds, #0     ; set time to 0
0770 754B04     566       mov FSM_state, #4
0773            567   FSM_state3_done:
0773 0206A7     568       ljmp FSM
0776            569            
0776            570   intermediate_state_0:
0776 0206A9     571            ljmp FSM_state0
0779            572   
0779            573   intermediate_stop_jump:
0779 020700     574            ljmp stop_state
077C            575   
077C            576   FSM_state4:
077C B40432     577       cjne a, #4, FSM_state5
077F 754714     578       mov pwm, #20
0782 E542       579       mov a, reflow_time    ; set a to reflow time
0784 C0E0       580            push acc
0786 7401       580            mov a, #1
0788 14         580            dec a
0789 12010F     580            lcall ?Set_Cursor_2 ; Select column and row
078C D0E0       580            pop acc
078E C083       581            push dph
0790 C082       581            push dpl
0792 C0E0       581            push acc
0794 900055     581            mov dptr, #Reflow_display
0797 120104     581            lcall ?Send_Constant_String
079A D0E0       581            pop acc
079C D082       581            pop dpl
079E D083       581            pop dph
07A0 C3         582       clr c   ; ! i don't know what is c 
07A1 3007D5     583       jnb start_stop_flag, intermediate_stop_jump; checks the flag if 0, then means stop was pressed, if 1 keep on going
07A4 953F       584       subb a, seconds    ; temp is our currect sec
07A6 5006       585       jnc FSM_state4_done
07A8 753F00     586       mov seconds, #0     ; set time to 0
07AB 754B05     587       mov FSM_state, #5
07AE            588   FSM_state4_done:
07AE 0206A7     589       ljmp FSM
07B1            590   
07B1            591   FSM_state5:
07B1 B405C2     592       cjne a, #5, intermediate_state_0
07B4 754700     593       mov pwm, #0
07B7 743C       594       mov a, #60    ; set a to 60
07B9 C0E0       595            push acc
07BB 7401       595            mov a, #1
07BD 14         595            dec a
07BE 12010F     595            lcall ?Set_Cursor_2 ; Select column and row
07C1 D0E0       595            pop acc
07C3 C083       596            push dph
07C5 C082       596            push dpl
07C7 C0E0       596            push acc
07C9 900064     596            mov dptr, #Cooling_display
07CC 120104     596            lcall ?Send_Constant_String
07CF D0E0       596            pop acc
07D1 D082       596            pop dpl
07D3 D083       596            pop dph
07D5 C3         597       clr c   ; ! i don't know what is c
07D6 3007A0     598       jnb start_stop_flag, intermediate_stop_jump ; checks the flag if 0, then means stop was pressed, if 1 keep on going 
07D9 9548       599       subb a, temp    ; temp is our currect temp, need to be edit
07DB 5006       600       jnc FSM_state5_done
07DD 753F00     601       mov seconds, #0     ; set time to 0
07E0 754B00     602       mov FSM_state, #0
07E3            603   FSM_state5_done:
07E3 0206A7     604       ljmp FSM
07E6            605   EN
