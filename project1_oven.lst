                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             21   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             22   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             23   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             25   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             26   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             27   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             28   
0000             29   ;---------------------------------;
0000             30   ; Define any buttons & pins here  ;
0000             31   ;---------------------------------;
0000             32   ;!!!!!arbiturary value for now
0000             33   START_STOP  equ p1.3 ; start/stop button
0000             34   INCREMENT   equ p1.5 ; increment button
0000             35   DECREMENT   equ p1.6 ; decrement button
0000             36   SWITCH_MODE equ p1.7 ; switch stting mode: soak temp -> soak time -> reflow temp -> reflow time
0000             37   SOUND_OUT   equ p3.0 ; speaker pin
0000             38   ;---------------------------------------------
0000             39   ORG 0x0000
0000 020488      40            ljmp main
0003             41   
0003             42   ;---------------------------------;
0003             43   ; Define any constant string here ;
0003             44   ;---------------------------------;
0003             45   ;                1234567890123456    <- This helps determine the location of the counter
0003 546F3D78    46   To_Message:  db 'To=xxxC Tj= xxC', 0
     78784320
     546A3D20
     78784300
0013 73787878    47   Time_temp_display:db 'sxxx,xx rxxx,xx', 0 ; soak temp,time reflow temp,time
     2C787820
     72787878
     2C787800
0023             48   ;---------------------------------------------
0023             49   cseg
0023             50   
0023             51   LCD_RS equ P1.3
0023             52   LCD_E  equ P1.4
0023             53   LCD_D4 equ P0.0
0023             54   LCD_D5 equ P0.1
0023             55   LCD_D6 equ P0.2
0023             56   LCD_D7 equ P0.3
0023             57   
                 59   	$LIST
00D7             61   
00D7             62   ;---------------------------------;
00D7             63   ; Define variables here           ;
00D7             64   ;---------------------------------;
00D7             65   ; These register definitions needed by 'math32.inc'
0030             66   DSEG at 30H
0030             67   x:   ds 4
0034             68   y:   ds 4
0038             69   bcd: ds 5   ;temperature variable for reading
003D             70   Count1ms:     ds 2 ; Used to determine when half second has passed
003F             71   ;BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
003F             72   Sec_counter: ds 2
0041             73   VLED_ADC: ds 2
0043             74   reflow_time: ds 2 ; time parameter for reflow    
0045             75   reflow_temp: ds 5 ; temp parameter for reflow
004A             76   soak_time: ds 2 ; time parameter for soak
004C             77   soak_temp: ds 5 ; temp parameter for soak
0051             78   ;---------------------------------------------
0051             79   
0051             80   ;---------------------------------;
0051             81   ; Define flags here               ;
0051             82   ;---------------------------------;
0000             83   BSEG
0000             84   mf: dbit 1
0001             85   one_second_flag: dbit 1 ; Set to one in the ISR every time 1000 ms had passed
0002             86   start_stop_flag: dbit 1 ; Set to one if button is pressed to start, press again to stop
0003             87   ;---------------------------------------------
0003             88   
                546   $LIST
                 90   $LIST
0347             92   
0347             93   ;---------------------------------;
0347             94   ; Routine to initialize the ISR   ;
0347             95   ; for timer 0                     ;
0347             96   ;---------------------------------;
0347             97   Timer0_Init:
0347 438E08      98            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
034A E589        99            mov a, TMOD
034C 54F0       100            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
034E 4401       101            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
0350 F589       102            mov TMOD, a
0352 758CF0     103            mov TH0, #high(TIMER0_RELOAD)
0355 758A2C     104            mov TL0, #low(TIMER0_RELOAD)
0358            105            ; Enable the timer and interrupts
0358 D2A9       106       setb ET0  ; Enable timer 0 interrupt
035A D28C       107       setb TR0  ; Start timer 0
035C 22         108            ret
035D            109   
035D            110   ;---------------------------------;
035D            111   ; ISR for timer 0.  Set to execute;
035D            112   ; every 1/4096Hz to generate a    ;
035D            113   ; 2048 Hz wave at pin SOUND_OUT   ;
035D            114   ;---------------------------------;
035D            115   Timer0_ISR:
035D            116            ;clr TF0  ; According to the data sheet this is done for us already.
035D            117            ; Timer 0 doesn't have 16-bit auto-reload, so
035D C28C       118            clr TR0
035F 758CF0     119            mov TH0, #high(TIMER0_RELOAD)
0362 758A2C     120            mov TL0, #low(TIMER0_RELOAD)
0365 D28C       121            setb TR0
0367 B2B0       122            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
0369 32         123            reti
036A            124   
036A            125   ;---------------------------------;
036A            126   ; Routine to initialize the ISR   ;
036A            127   ; for timer 2                     ;
036A            128   ;---------------------------------;
036A            129   Timer2_Init:
036A 75C800     130            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
036D 75CDBF     131            mov TH2, #high(TIMER2_RELOAD)
0370 75CC28     132            mov TL2, #low(TIMER2_RELOAD)
0373            133            ; Set the reload value
0373 43C980     134            orl T2MOD, #0x80 ; Enable timer 2 autoreload
0376 75CBBF     135            mov RCMP2H, #high(TIMER2_RELOAD)
0379 75CA28     136            mov RCMP2L, #low(TIMER2_RELOAD)
037C            137            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
037C E4         138            clr a
037D F53D       139            mov Count1ms+0, a
037F F53E       140            mov Count1ms+1, a
0381            141            ; Enable the timer and interrupts
0381 439B80     142            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0384 D2CA       143       setb TR2  ; Enable timer 2
0386 22         144            ret
0387            145   
0387            146   ;---------------------------------;
0387            147   ; ISR for timer 2 for +/-         ;
0387            148   ;---------------------------------;
0387            149   Timer2_ISR:
0387 C2CF       150            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
0389 B284       151            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
038B            152            
038B            153            ; The two registers used in the ISR must be saved in the stack
038B C0E0       154            push acc
038D C0D0       155            push psw
038F            156            
038F            157            ; Increment the 16-bit one mili second counter
038F 053D       158            inc Count1ms+0    ; Increment the low 8-bits first
0391 E53D       159            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0393 7002       160            jnz Inc_Done
0395 053E       161            inc Count1ms+1
0397            162   
0397            163   ;---------------------------------;
0397            164   ; ISR for timer 0.  Set to execute;
0397            165   ; every 1/4096Hz to generate a    ;
0397            166   ; 2048 Hz wave at pin SOUND_OUT   ;
0397            167   ;---------------------------------;
0397            168   
0397            169   Inc_Done:
0397            170            ; Check if one second has passed
0397 E53D       171            mov a, Count1ms+0
0399 B4E815     172            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
039C E53E       173            mov a, Count1ms+1
039E B40310     174            cjne a, #high(1000), Timer2_ISR_done
03A1            175            
03A1            176            ; 1000 milliseconds have passed.  Set a flag so the main program knows
03A1 D201       177            setb one_second_flag ; Let the main program know one second had passed
03A3            178            ;cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
03A3            179            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
03A3            180            
03A3 E4         181            clr a
03A4 F53D       182            mov Count1ms+0, a
03A6 F53E       183            mov Count1ms+1, a
03A8            184            ; Increment the BCD counter
03A8            185            ;mov a, BCD_counter
03A8            186   
03A8 E53F       187       mov a, Sec_counter
03AA 2401       188            add a, #0x01 
03AC D4         189            da A
03AD F53F       190            mov Sec_counter,a
03AF 8000       191            sjmp Timer2_ISR_done
03B1            192   
03B1            193       ;In case it does not work look for the decrement part
03B1            194   
03B1            195   Timer2_ISR_done:
03B1 D0D0       196            pop psw
03B3 D0E0       197            pop acc
03B5 32         198            reti
03B6            199   
03B6            200   ;---------------------------------;
03B6            201   ; Temperature senseor function    ;
03B6            202   ;---------------------------------;
03B6            203   Init_All:
03B6            204            ; Configure all the pins for biderectional I/O
03B6 75AC00     205            mov     P3M1, #0x00
03B9 75AD00     206            mov     P3M2, #0x00
03BC 75B300     207            mov     P1M1, #0x00
03BF 75B400     208            mov     P1M2, #0x00
03C2 75B100     209            mov     P0M1, #0x00
03C5 75B200     210            mov     P0M2, #0x00
03C8            211            
03C8 438E10     212            orl     CKCON, #0x10 ; CLK is the input for timer 1
03CB 438780     213            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
03CE 759852     214            mov     SCON, #0x52
03D1 53C4DF     215            anl     T3CON, #0b11011111
03D4 53890F     216            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
03D7 438920     217            orl     TMOD, #0x20 ; Timer 1 Mode 2
03DA 758DF7     218            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
03DD D28E       219            setb TR1
03DF            220            
03DF            221            ; Using timer 0 for delay functions.  Initialize here:
03DF C28C       222            clr     TR0 ; Stop timer 0
03E1 438E08     223            orl     CKCON,#0x08 ; CLK is the input for timer 0
03E4 5389F0     224            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
03E7 438901     225            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
03EA            226            
03EA            227            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
03EA 43B382     228            orl     P1M1, #0b10000010
03ED 53B47D     229            anl     P1M2, #0b01111101
03F0            230            
03F0            231            ; Initialize and start the ADC:
03F0 53E8F0     232            anl ADCCON0, #0xF0
03F3 43E807     233            orl ADCCON0, #0x07 ; Select channel 7
03F6            234            ; AINDIDS select if some pins are analog inputs or digital I/O:
03F6 75F600     235            mov AINDIDS, #0x00 ; Disable all analog inputs
03F9 43F681     236            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
03FC 43E101     237            orl ADCCON1, #0x01 ; Enable ADC
03FF            238            
03FF 22         239            ret
0400            240            
0400            241   ; Send a character using the serial port
0400            242   putchar:
0400 3099FD     243       jnb TI, putchar
0403 C299       244       clr TI
0405 F599       245       mov SBUF, a
0407 22         246       ret
0408            247   
0408            248   wait_1ms:
0408 C28C       249            clr     TR0 ; Stop timer 0
040A C28D       250            clr     TF0 ; Clear overflow flag
040C 758CBF     251            mov     TH0, #high(TIMER0_RELOAD_1MS)
040F 758A28     252            mov     TL0,#low(TIMER0_RELOAD_1MS)
0412 D28C       253            setb TR0
0414 308DFD     254            jnb     TF0, $ ; Wait for overflow
0417 22         255            ret
0418            256   
0418            257   ; Wait the number of miliseconds in R2
0418            258   waitms:
0418 120408     259            lcall wait_1ms
041B DAFB       260            djnz R2, waitms
041D 22         261            ret
041E            262   
041E            263   ;---------------------------------;
041E            264   ; Send a BCD number to PuTTY      ;
041E            265   ;---------------------------------;
                266   Send_BCD mac
                267   	push ar0
                268   	mov r0, %0
                269   	lcall ?Send_BCD
                270   	pop ar0
                271   endmac
041E            272   
041E            273   ?Send_BCD:
041E C0E0       274            push acc
0420            275            ; Write most significant digit
0420 E8         276            mov a, r0
0421 C4         277            swap a
0422 540F       278            anl a, #0fh
0424 4430       279            orl a, #30h
0426 120400     280            lcall putchar
0429            281            ; write least significant digit
0429 E8         282            mov a, r0
042A 540F       283            anl a, #0fh
042C 4430       284            orl a, #30h
042E 120400     285            lcall putchar
0431 D0E0       286            pop acc
0433 22         287            ret
0434            288   
0434            289   ; We can display a number any way we want.  In this case with
0434            290   ; four decimal places.
0434            291   Display_formated_BCD:
0434 C0E0       292            push acc
0436 740A       292            mov a, #10
0438 14         292            dec a
0439 1200BA     292            lcall ?Set_Cursor_2 ; Select column and row
043C D0E0       292            pop acc
043E C000       293            push ar0
0440 A83A       293            mov r0, bcd+2
0442 1200C1     293            lcall ?Display_BCD
0445 D000       293            pop ar0
0447 C0E0       294            push acc
0449 742E       294            mov a, #'.'
044B 120072     294            lcall ?WriteData
044E D0E0       294            pop acc
0450 C000       295            push ar0
0452 A839       295            mov r0, bcd+1
0454 1200C1     295            lcall ?Display_BCD
0457 D000       295            pop ar0
0459 C000       296            push ar0
045B A838       296            mov r0, bcd+0
045D 1200C1     296            lcall ?Display_BCD
0460 D000       296            pop ar0
0462 C0E0       297            push acc
0464 740A       297            mov a, #10
0466 14         297            dec a
0467 1200BA     297            lcall ?Set_Cursor_2 ; Select column and row
046A D0E0       297            pop acc
046C            298            ;Display_char(#'=')
046C 22         299            ret
046D            300   
046D            301   Read_ADC:
046D C2EF       302            clr ADCF
046F D2EE       303            setb ADCS ;  ADC start trigger signal
0471 30EFFD     304       jnb ADCF, $ ; Wait for conversion complete
0474            305       
0474            306       ; Read the ADC result and store in [R1, R0]
0474 E5C2       307       mov a, ADCRL
0476 540F       308       anl a, #0x0f
0478 F8         309       mov R0, a
0479 E5C3       310       mov a, ADCRH   
047B C4         311       swap a
047C C0E0       312       push acc
047E 540F       313       anl a, #0x0f
0480 F9         314       mov R1, a
0481 D0E0       315       pop acc
0483 54F0       316       anl a, #0xf0
0485 48         317       orl a, R0
0486 F8         318       mov R0, A
0487 22         319            ret
0488            320   
0488            321   ;-------------------------------------------------;
0488            322   ; Display all values and temperatures to the LCD  ;
0488            323   ;-------------------------------------------------;
0488            324   
0488            325   Display_LCD:
0488            326            
0488            327   
0488            328   main:
0488 75817F     329            mov sp, #0x7f
048B 1203B6     330            lcall Init_All
048E 12007C     331       lcall LCD_4BIT
0491            332       
0491            333       ; initial messages in LCD
0491 C0E0       334            push acc
0493 7401       334            mov a, #1
0495 14         334            dec a
0496 1200BC     334            lcall ?Set_Cursor_1 ; Select column and row
0499 D0E0       334            pop acc
049B C083       335            push dph
049D C082       335            push dpl
049F C0E0       335            push acc
04A1 900003     335            mov dptr, #To_Message
04A4 1200AF     335            lcall ?Send_Constant_String
04A7 D0E0       335            pop acc
04A9 D082       335            pop dpl
04AB D083       335            pop dph
04AD C0E0       336            push acc
04AF 7401       336            mov a, #1
04B1 14         336            dec a
04B2 1200BA     336            lcall ?Set_Cursor_2 ; Select column and row
04B5 D0E0       336            pop acc
04B7 C083       337            push dph
04B9 C082       337            push dpl
04BB C0E0       337            push acc
04BD 900013     337            mov dptr, #Time_temp_display
04C0 1200AF     337            lcall ?Send_Constant_String
04C3 D0E0       337            pop acc
04C5 D082       337            pop dpl
04C7 D083       337            pop dph
04C9            338            
04C9 753F00     339            mov Sec_counter, #0x00
04CC D2CA       340            setb TR2
04CE            341       
04CE            342   Forever:
04CE            343   
04CE            344            ; Read the 2.08V LED voltage connected to AIN0 on pin 6
04CE 53E8F0     345            anl ADCCON0, #0xF0
04D1 43E800     346            orl ADCCON0, #0x00 ; Select channel 0
04D4            347   
04D4 12046D     348            lcall Read_ADC
04D7            349            ; Save result for later use
04D7 8841       350            mov VLED_ADC+0, R0
04D9 8942       351            mov VLED_ADC+1, R1
04DB            352   
04DB            353            ; Read the signal connected to AIN7
04DB 53E8F0     354            anl ADCCON0, #0xF0
04DE 43E807     355            orl ADCCON0, #0x07 ; Select channel 7
04E1 12046D     356            lcall Read_ADC
04E4            357       
04E4            358       ; Convert to voltage
04E4 8830       359            mov x+0, R0
04E6 8931       360            mov x+1, R1
04E8            361            ; Pad other bits with zero
04E8 753200     362            mov x+2, #0
04EB 753300     363            mov x+3, #0
04EE 753404     364            mov y+0, #low (20740 % 0x10000) 
04F1 753551     364            mov y+1, #high(20740 % 0x10000) 
04F4 753600     364            mov y+2, #low (20740 / 0x10000) 
04F7 753700     364            mov y+3, #high(20740 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
04FA 120251     365            lcall mul32 ; Get ADC * V_ref
04FD            366            ; Retrive the ADC LED value
04FD 854134     367            mov y+0, VLED_ADC+0
0500 854235     368            mov y+1, VLED_ADC+1
0503            369            ; Pad other bits with zero
0503 753600     370            mov y+2, #0
0506 753700     371            mov y+3, #0
0509 1202DE     372            lcall div32 ; Get V_out
050C            373            ; Calculate Temp based on V_out
050C 7534A4     374            mov y+0, #low (27300 % 0x10000) 
050F 75356A     374            mov y+1, #high(27300 % 0x10000) 
0512 753600     374            mov y+2, #low (27300 / 0x10000) 
0515 753700     374            mov y+3, #high(27300 / 0x10000)  ; The reference temp K
0518 1201BD     375            lcall sub32 ; Get Temp*0.01
051B            376            ; Change Temp*0.01 to Temp
051B 753464     377            mov y+0, #low (100 % 0x10000) 
051E 753500     377            mov y+1, #high(100 % 0x10000) 
0521 753600     377            mov y+2, #low (100 / 0x10000) 
0524 753700     377            mov y+3, #high(100 / 0x10000) 
0527 120251     378            lcall mul32
052A            379   
052A            380            ; Convert to BCD and display
052A 1200D7     381            lcall hex2bcd
052D 120434     382            lcall Display_formated_BCD
0530 C000       383            push ar0
0532 A83C       383            mov r0, bcd+4
0534 12041E     383            lcall ?Send_BCD
0537 D000       383            pop ar0
0539 C000       384            push ar0
053B A83B       384            mov r0, bcd+3
053D 12041E     384            lcall ?Send_BCD
0540 D000       384            pop ar0
0542 C000       385            push ar0
0544 A83A       385            mov r0, bcd+2
0546 12041E     385            lcall ?Send_BCD
0549 D000       385            pop ar0
054B 742E       386            mov a, #'.' ; I am guessing the decimal point is here...
054D 120400     387            lcall putchar
0550 C000       388            push ar0
0552 A839       388            mov r0, bcd+1
0554 12041E     388            lcall ?Send_BCD
0557 D000       388            pop ar0
0559 C000       389            push ar0
055B A838       389            mov r0, bcd+0
055D 12041E     389            lcall ?Send_BCD
0560 D000       389            pop ar0
0562 740D       390            mov a, #'\r' ; Return character
0564 120400     391            lcall putchar
0567 740A       392            mov a, #'\n' ; New-line character
0569 120400     393            lcall putchar
056C            394            
056C            395            ; Wait 500 ms between conversions
056C 7AFA       396            mov R2, #250
056E 120418     397            lcall waitms
0571 7AFA       398            mov R2, #250
0573 120418     399            lcall waitms
0576            400            
0576 0204CE     401            ljmp Forever
0579            402   EN
