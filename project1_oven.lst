                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             21   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             22   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             23   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             25   TIMER0_RELOAD_1MS EQU (0x10000-(CLK/1000))
0000             26   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             27   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             28   
0000             29   ;---------------------------------;
0000             30   ; Define any buttons & pins here  ;
0000             31   ;---------------------------------;
0000             32   ;!!!!!arbiturary value for now
0000             33   SOUND_OUT   equ p1.7 ; speaker pin
0000             34   ; Output
0000             35   PWM_OUT    EQU P1.0 ; Logic 1=oven on
0000             36   ;---------------------------------------------
0000             37   ORG 0x0000
0000 020610      38            ljmp main
0003             39   
0003             40   ;---------------------------------;
0003             41   ; Define any constant string here ;
0003             42   ;---------------------------------;
0003             43   ;                          1234567890123456    <- This helps determine the location of the counter
0003 546F3D78    44   To_Message:        db 'To=xxxC Tj= 22C ', 0
     78784320
     546A3D20
     32324320
     00
0014 73787878    45   Time_temp_display:db 'sxxx,xx rxxx,xx ', 0 ; soak temp,time reflow temp,time
     2C787820
     72787878
     2C787820
     00
0025 52616D70    46   Ramp_to_soak:      db 'RampToSoak s=xxx', 0 ; state 1 display
     546F536F
     616B2073
     3D787878
     00
0036 536F616B    47   Soak_display:      db 'Soak               s=xxx', 0 ; state 2 display
     20090920
     733D7878
     7800
0044 52616D70    48   Ramp_to_peak:      db 'RampToPeak s=xxx', 0 ; state 3 display
     546F5065
     616B2073
     3D787878
     00
0055 5265666C    49   Reflow_display:   db 'Reflow      s=xxx', 0 ; state 4 display
     6F772009
     20733D78
     787800
0064 436F6F6C    50   Cooling_display:  db 'Cooling     s=xxx', 0 ; state 5 display
     696E6720
     0920733D
     78787800
0074             51   ;---------------------------------------------
0074             52   cseg
0074             53   
0074             54   LCD_RS equ P1.3
0074             55   LCD_E  equ P1.4
0074             56   LCD_D4 equ P0.0
0074             57   LCD_D5 equ P0.1
0074             58   LCD_D6 equ P0.2
0074             59   LCD_D7 equ P0.3
0074             60   
                 62   $LIST
013E             64   
013E             65   ;---------------------------------;
013E             66   ; Define variables here           ;
013E             67   ;---------------------------------;
013E             68   ; These register definitions needed by 'math32.inc'
0030             69   DSEG at 30H
0030             70   x:   ds 4
0034             71   y:   ds 4
0038             72   bcd: ds 5   ;temperature variable for reading
003D             73   Count1ms:     ds 2 ; Used to determine when one second has passed
003F             74   seconds: ds 1
0040             75   VLED_ADC: ds 2
0042             76   reflow_time: ds 1 ; time parameter for reflow    
0043             77   reflow_temp: ds 1 ; temp parameter for reflow
0044             78   soak_time: ds 1 ; time parameter for soak
0045             79   soak_temp: ds 1 ; temp parameter for soak
0046             80   pwm_counter: ds 1 ; power counter
0047             81   pwm: ds 1 ; variable to count the power percentage
0048             82   temp: ds 3
004B             83   FSM_state: ds 1
004C             84   ;---------------------------------------------
004C             85   
004C             86   ;---------------------------------;
004C             87   ; Define flags here               ;
004C             88   ;---------------------------------;
0000             89   BSEG
0000             90   mf: dbit 1
0001             91   s_flag: dbit 1 ; Set to one in the ISR every time 1000 ms had passed
0002             92   PB0: dbit 1      ; start/stop
0003             93   PB1: dbit 1      ; increment reflow time
0004             94   PB2: dbit 1      ; increment reflow temp
0005             95   PB3: dbit 1      ; increment soak time
0006             96   PB4: dbit 1      ; increment soak temp
0007             97   start_stop_flag: dbit 1 ; Set to one if button is pressed to start, press again to stop
0008             98   ;---------------------------------------------
0008             99   
                546   $LIST
                101   $LIST
03AE            103   
03AE            104   ;---------------------------------;
03AE            105   ; Routine to initialize the ISR   ;
03AE            106   ; for timer 0                     ;
03AE            107   ;---------------------------------;
03AE            108   Timer0_Init:
03AE 438E08     109            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
03B1 E589       110            mov a, TMOD
03B3 54F0       111            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03B5 4401       112            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03B7 F589       113            mov TMOD, a
03B9 758CF0     114            mov TH0, #high(TIMER0_RELOAD)
03BC 758A2C     115            mov TL0, #low(TIMER0_RELOAD)
03BF            116            ; Enable the timer and interrupts
03BF D2A9       117       setb ET0  ; Enable timer 0 interrupt
03C1 D28C       118       setb TR0  ; Start timer 0
03C3 22         119            ret
03C4            120   
03C4            121   ;---------------------------------;
03C4            122   ; ISR for timer 0.  Set to execute;
03C4            123   ; every 1/4096Hz to generate a    ;
03C4            124   ; 2048 Hz wave at pin SOUND_OUT   ;
03C4            125   ;---------------------------------;
03C4            126   Timer0_ISR:
03C4            127            ;clr TF0  ; According to the data sheet this is done for us already.
03C4            128            ; Timer 0 doesn't have 16-bit auto-reload, so
03C4 C28C       129            clr TR0
03C6 758CF0     130            mov TH0, #high(TIMER0_RELOAD)
03C9 758A2C     131            mov TL0, #low(TIMER0_RELOAD)
03CC D28C       132            setb TR0
03CE B297       133            cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
03D0 32         134            reti
03D1            135   
03D1            136   ;---------------------------------;
03D1            137   ; Routine to initialize the ISR   ;
03D1            138   ; for timer 2                     ;
03D1            139   ;---------------------------------;
03D1            140   Timer2_Init:
03D1 75C800     141            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
03D4 75CDBF     142            mov TH2, #high(TIMER2_RELOAD)
03D7 75CC28     143            mov TL2, #low(TIMER2_RELOAD)
03DA            144            ; Set the reload value
03DA 43C980     145            orl T2MOD, #0x80 ; Enable timer 2 autoreload
03DD 75CBBF     146            mov RCMP2H, #high(TIMER2_RELOAD)
03E0 75CA28     147            mov RCMP2L, #low(TIMER2_RELOAD)
03E3            148            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
03E3 E4         149            clr a
03E4 F53D       150            mov Count1ms+0, a
03E6 F53E       151            mov Count1ms+1, a
03E8 754700     152            mov pwm, #0
03EB            153            ; Enable the timer and interrupts
03EB 439B80     154            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
03EE D2CA       155       setb TR2  ; Enable timer 2
03F0 22         156            ret
03F1            157   
03F1            158   ;---------------------------------;
03F1            159   ; ISR for timer 2 ;
03F1            160   ;---------------------------------;
03F1            161   Timer2_ISR:
03F1 C2CF       162            clr TF2 ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR. It is bit addressable.
03F3 B284       163            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
03F5            164                    
03F5            165            ; The two registers used in the ISR must be saved in the stack
03F5 C0D0       166            push psw
03F7 C0E0       167            push acc
03F9 0546       168            inc pwm_counter
03FB C3         169            clr c
03FC E547       170            mov a, pwm
03FE 9546       171            subb a, pwm_counter ; If pwm_counter <= pwm then c=1
0400 B3         172            cpl c
0401 9290       173            mov PWM_OUT, c
0403 E546       174            mov a, pwm_counter
0405 B46407     175            cjne a, #100, Timer2_ISR_done
0408 754600     176            mov pwm_counter, #0
040B 053F       177            inc seconds ; It is super easy to keep a seconds count here
040D D201       178            setb s_flag
040F            179   
040F            180   Timer2_ISR_done:
040F D0E0       181            pop acc
0411 D0D0       182            pop psw
0413 32         183            reti
0414            184   
0414            185   ;---------------------------------;
0414            186   ; Temperature senseor function    ;
0414            187   ;---------------------------------;
0414            188   Init_All:
0414            189            ; Configure all the pins for biderectional I/O
0414 75AC00     190            mov     P3M1, #0x00
0417 75AD00     191            mov     P3M2, #0x00
041A 75B300     192            mov     P1M1, #0x00
041D 75B400     193            mov     P1M2, #0x00
0420 75B100     194            mov     P0M1, #0x00
0423 75B200     195            mov     P0M2, #0x00
0426            196            
0426 438E10     197            orl     CKCON, #0x10 ; CLK is the input for timer 1
0429 438780     198            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
042C 759852     199            mov     SCON, #0x52
042F 53C4DF     200            anl     T3CON, #0b11011111
0432 53890F     201            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
0435 438920     202            orl     TMOD, #0x20 ; Timer 1 Mode 2
0438 758DF7     203            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
043B D28E       204            setb TR1
043D            205            
043D            206            ; Using timer 0 for delay functions.  Initialize here:
043D C28C       207            clr     TR0 ; Stop timer 0
043F 438E08     208            orl     CKCON,#0x08 ; CLK is the input for timer 0
0442 5389F0     209            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
0445 438901     210            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
0448            211            
0448            212            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
0448 43B382     213            orl     P1M1, #0b10000010
044B 53B47D     214            anl     P1M2, #0b01111101
044E            215            
044E            216            ; Initialize and start the ADC:
044E 53E8F0     217            anl ADCCON0, #0xF0
0451 43E807     218            orl ADCCON0, #0x07 ; Select channel 7
0454            219            ; AINDIDS select if some pins are analog inputs or digital I/O:
0454 75F600     220            mov AINDIDS, #0x00 ; Disable all analog inputs
0457 43F681     221            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
045A 43E101     222            orl ADCCON1, #0x01 ; Enable ADC
045D            223            
045D 22         224            ret
045E            225            
045E            226   ; Send a character using the serial port
045E            227   putchar:
045E 3099FD     228       jnb TI, putchar
0461 C299       229       clr TI
0463 F599       230       mov SBUF, a
0465 22         231       ret
0466            232   
0466            233   wait_1ms:
0466 C28C       234            clr     TR0 ; Stop timer 0
0468 C28D       235            clr     TF0 ; Clear overflow flag
046A 758CBF     236            mov     TH0, #high(TIMER0_RELOAD_1MS)
046D 758A28     237            mov     TL0,#low(TIMER0_RELOAD_1MS)
0470 D28C       238            setb TR0
0472 308DFD     239            jnb     TF0, $ ; Wait for overflow
0475 22         240            ret
0476            241   
0476            242   ; Wait the number of miliseconds in R2
0476            243   waitms:
0476 120466     244            lcall wait_1ms
0479 DAFB       245            djnz R2, waitms
047B 22         246            ret
047C            247   
047C            248   ;---------------------------------;
047C            249   ;         5_pushbuttons function               ;
047C            250   ;---------------------------------;
047C            251   LCD_PB:
047C            252            ; Set variables to 1: 'no push button pressed'
047C D202       253            setb PB0
047E D203       254            setb PB1
0480 D204       255            setb PB2
0482 D205       256            setb PB3
0484 D206       257            setb PB4
0486            258            ; The input pin used to check set to '1'
0486 D295       259            setb P1.5
0488            260            
0488            261            ; Check if any push button is pressed
0488 C280       262            clr P0.0
048A C281       263            clr P0.1
048C C282       264            clr P0.2
048E C283       265            clr P0.3
0490 C293       266            clr P1.3
0492 209549     267            jb P1.5, LCD_PB_Done
0495            268   
0495            269            ; Debounce
0495 7A32       270            mov R2, #50
0497 120476     271            lcall waitms
049A 209541     272            jb P1.5, LCD_PB_Done
049D            273   
049D            274            ; Set the LCD data pins to logic 1
049D D280       275            setb P0.0
049F D281       276            setb P0.1
04A1 D282       277            setb P0.2
04A3 D283       278            setb P0.3
04A5 D293       279            setb P1.3
04A7            280            
04A7            281            ; Check the push buttons one by one
04A7 C293       282            clr P1.3
04A9 A295       283            mov c, P1.5
04AB 9206       284            mov PB4, c
04AD D293       285            setb P1.3
04AF 30062D     286            jnb PB4,increment_soak_temp
04B2            287   
04B2 C280       288            clr P0.0
04B4 A295       289            mov c, P1.5
04B6 9205       290            mov PB3, c
04B8 D280       291            setb P0.0
04BA 30052E     292            jnb PB3, increment_soak_time
04BD            293            
04BD C281       294            clr P0.1
04BF A295       295            mov c, P1.5
04C1 9204       296            mov PB2, c
04C3 D281       297            setb P0.1
04C5 30042F     298            jnb PB2, increment_reflow_temp
04C8            299            
04C8 C282       300            clr P0.2
04CA A295       301            mov c, P1.5
04CC 9203       302            mov PB1, c
04CE D282       303            setb P0.2
04D0 300330     304            jnb PB1, increment_reflow_time
04D3            305            
04D3 C283       306            clr P0.3
04D5 A295       307            mov c, P1.5
04D7 9202       308            mov PB0, c
04D9 D283       309            setb P0.3
04DB 300231     310            jnb PB0, start_stop
04DE            311   
04DE            312   
04DE            313   LCD_PB_Done:             
04DE 22         314            ret
04DF            315   
04DF            316   increment_soak_temp:
04DF 0545       317            inc soak_temp
04E1 E545       318            mov a, soak_temp
04E3 B4F0F8     319            cjne a, #240, LCD_PB_Done
04E6 754500     320            mov soak_temp, #0x00
04E9 80F3       321            sjmp LCD_PB_Done
04EB            322   increment_soak_time:
04EB 0544       323            inc soak_time
04ED E544       324            mov a, soak_time
04EF B478EC     325            cjne a, #120, LCD_PB_Done
04F2 754400     326            mov soak_time, #0x00
04F5 80E7       327            sjmp LCD_PB_Done
04F7            328   increment_reflow_temp: 
04F7 0543       329            inc reflow_temp
04F9 E543       330            mov a, reflow_temp
04FB B4F0E0     331            cjne a, #240, LCD_PB_Done
04FE 754300     332            mov reflow_temp, #0x00
0501 80DB       333            sjmp LCD_PB_Done
0503            334   increment_reflow_time:
0503 0542       335            inc reflow_time
0505 E542       336            mov a, reflow_time
0507 B44BD4     337            cjne a, #75, LCD_PB_Done
050A 754200     338            mov reflow_time, #0x00
050D 80CF       339            sjmp LCD_PB_Done
050F            340   
050F            341   start_stop:
050F B207       342            cpl start_stop_flag
0511 80CB       343            sjmp LCD_PB_Done
0513            344   
0513            345   
0513            346   ; We can display a number any way we want.  In this case with
0513            347   ; four decimal places.
0513            348   Display_formated_BCD:
0513 C0E0       349            push acc
0515 7404       349            mov a, #4
0517 14         349            dec a
0518 12010D     349            lcall ?Set_Cursor_1 ; Select column and row
051B D0E0       349            pop acc ; display To
051D C000       350            push ar0
051F A83C       350            mov r0, bcd+4
0521 120112     350            lcall ?Display_BCD
0524 D000       350            pop ar0
0526 C000       351            push ar0
0528 A83B       351            mov r0, bcd+3
052A 120112     351            lcall ?Display_BCD
052D D000       351            pop ar0 ;this is just in case temperatures exceed 100C and we're in deg F
052F C000       352            push ar0
0531 A83A       352            mov r0, bcd+2
0533 120112     352            lcall ?Display_BCD
0536 D000       352            pop ar0
0538            353   
0538            354            ;Set_Cursor(1, 13)
0538            355            ;Send_Constant_String(#22) ; display Tj=22
0538 22         356            ret
0539            357   
0539            358   
0539            359   ;-------------------------------------------------;
0539            360   ; Display all values and temperatures to the LCD  ;
0539            361   ;-------------------------------------------------;
0539            362   Display_Data:
0539 C2EF       363            clr ADCF
053B D2EE       364            setb ADCS ;  ADC start trigger signal
053D 30EFFD     365       jnb ADCF, $ ; Wait for conversion complete
0540            366       
0540            367       ; Read the ADC result and store in [R1, R0]
0540 E5C3       368       mov a, ADCRH   
0542 C4         369       swap a
0543 C0E0       370       push acc
0545 540F       371       anl a, #0x0f
0547 F9         372       mov R1, a
0548 D0E0       373       pop acc
054A 54F0       374       anl a, #0xf0
054C 45C2       375       orl a, ADCRL
054E F8         376       mov R0, A
054F            377       
054F            378       ; Convert to voltage
054F 8830       379            mov x+0, R0
0551 8931       380            mov x+1, R1
0553            381            ; Pad other bits with zero
0553 753200     382            mov x+2, #0
0556 753300     383            mov x+3, #0
0559            384            
0559            385            ;lcall div32 ; Get V_out
0559            386            ; ; Calculate Temp based on V_out
0559            387            ; Load_y(27300) ; The reference temp K
0559            388            ; lcall sub32 ; Get Temp*0.01
0559            389            ; ; Change Temp*0.01 to Temp
0559            390            ; Load_y(100)
0559            391            ; lcall mul32
0559            392   
0559 75347C     393            mov y+0, #low (50300 % 0x10000) 
055C 7535C4     393            mov y+1, #high(50300 % 0x10000) 
055F 753600     393            mov y+2, #low (50300 / 0x10000) 
0562 753700     393            mov y+3, #high(50300 / 0x10000)  ; VCC voltage measured (equals 4.99V)
0565 1202B8     394            lcall mul32 ;multiplying ADC * Vref
0568 7534FF     395            mov y+0, #low (4095 % 0x10000) 
056B 75350F     395            mov y+1, #high(4095 % 0x10000) 
056E 753600     395            mov y+2, #low (4095 / 0x10000) 
0571 753700     395            mov y+3, #high(4095 / 0x10000)  ; 2^12-1
0574 120345     396            lcall div32 ;now doing (ADC*Vref)/(4095)
0577            397            
0577 7534E8     398            mov y+0, #low (1000 % 0x10000) 
057A 753503     398            mov y+1, #high(1000 % 0x10000) 
057D 753600     398            mov y+2, #low (1000 / 0x10000) 
0580 753700     398            mov y+3, #high(1000 / 0x10000)  ; for converting volt to microvolt
0583 1202B8     399            lcall mul32 ;multiplying volts
0586            400            
0586 75340A     401            mov y+0, #low (10 % 0x10000) 
0589 753500     401            mov y+1, #high(10 % 0x10000) 
058C 753600     401            mov y+2, #low (10 / 0x10000) 
058F 753700     401            mov y+3, #high(10 / 0x10000) 
0592 1202B8     402            lcall mul32
0595            403            
0595            404            ;convert to temperature
0595 7534CC     405            mov y+0, #low (23500 % 0x10000) 
0598 75355B     405            mov y+1, #high(23500 % 0x10000) 
059B 753600     405            mov y+2, #low (23500 / 0x10000) 
059E 753700     405            mov y+3, #high(23500 / 0x10000)  ;divide by the gain 
05A1 120345     406            lcall div32 
05A4 753429     407            mov y+0, #low (41 % 0x10000) 
05A7 753500     407            mov y+1, #high(41 % 0x10000) 
05AA 753600     407            mov y+2, #low (41 / 0x10000) 
05AD 753700     407            mov y+3, #high(41 / 0x10000) ;load y = 41
05B0 120345     408            lcall div32 ;divide by 41
05B3            409            
05B3 753410     410            mov y+0, #low (10000 % 0x10000) 
05B6 753527     410            mov y+1, #high(10000 % 0x10000) 
05B9 753600     410            mov y+2, #low (10000 / 0x10000) 
05BC 753700     410            mov y+3, #high(10000 / 0x10000) 
05BF 1202B8     411            lcall mul32
05C2            412            
05C2 753460     413            mov y+0, #low (220000 % 0x10000) 
05C5 75355B     413            mov y+1, #high(220000 % 0x10000) 
05C8 753603     413            mov y+2, #low (220000 / 0x10000) 
05CB 753700     413            mov y+3, #high(220000 / 0x10000)  ;cold junction 19 deg C
05CE 120203     414            lcall add32
05D1            415   
05D1            416   ; Convert to BCD and display
05D1 12013E     417            lcall hex2bcd
05D4 120513     418            lcall Display_formated_BCD
05D7            419            
05D7            420            ;send the BCD value to the MATLAB script
05D7 C000       421            push ar0
05D9 A83B       421            mov r0, bcd+3
05DB 120128     421            lcall ?Send_BCD
05DE D000       421            pop ar0
05E0 C000       422            push ar0
05E2 A83A       422            mov r0, bcd+2
05E4 120128     422            lcall ?Send_BCD
05E7 D000       422            pop ar0
05E9 C000       423            push ar0
05EB A839       423            mov r0, bcd+1
05ED 120128     423            lcall ?Send_BCD
05F0 D000       423            pop ar0
05F2 C000       424            push ar0
05F4 A838       424            mov r0, bcd
05F6 120128     424            lcall ?Send_BCD
05F9 D000       424            pop ar0
05FB 740D       425            mov a, #'\r'
05FD 12045E     426            lcall putchar
0600 740A       427            mov a, #'\n'
0602 12045E     428            lcall putchar
0605            429            
0605            430            ; Wait 500 ms between conversions
0605 7AFA       431            mov R2, #250
0607 120476     432            lcall waitms
060A 7AFA       433            mov R2, #250
060C 120476     434            lcall waitms
060F            435   
060F 32         436            reti
0610            437   
0610            438   main:
0610 75817F     439            mov sp, #0x7f
0613 120414     440            lcall Init_All
0616 1200CD     441       lcall LCD_4BIT
0619 1203AE     442       lcall Timer0_Init
061C 1203D1     443       lcall Timer2_Init
061F D2AF       444       setb EA   ; Enable Global interrupts
0621            445       ; initial messages in LCD
0621 C0E0       446            push acc
0623 7401       446            mov a, #1
0625 14         446            dec a
0626 12010D     446            lcall ?Set_Cursor_1 ; Select column and row
0629 D0E0       446            pop acc
062B C083       447            push dph
062D C082       447            push dpl
062F C0E0       447            push acc
0631 900003     447            mov dptr, #To_Message
0634 120100     447            lcall ?Send_Constant_String
0637 D0E0       447            pop acc
0639 D082       447            pop dpl
063B D083       447            pop dph
063D C0E0       448            push acc
063F 7401       448            mov a, #1
0641 14         448            dec a
0642 12010B     448            lcall ?Set_Cursor_2 ; Select column and row
0645 D0E0       448            pop acc
0647 C083       449            push dph
0649 C082       449            push dpl
064B C0E0       449            push acc
064D 900014     449            mov dptr, #Time_temp_display
0650 120100     449            lcall ?Send_Constant_String
0653 D0E0       449            pop acc
0655 D082       449            pop dpl
0657 D083       449            pop dph
0659            450            
0659 753F00     451            mov seconds, #0x00
065C 7545E0     452            mov soak_temp, #0xE0 
065F 754460     453            mov soak_time, #0x60
0662 7543E6     454            mov reflow_temp, #0xE6 ; 230
0665 754230     455            mov reflow_time, #0x30
0668 D2CA       456            setb TR2
066A            457       
066A            458   ;---------------------------------;
066A            459   ;                FSM     funtion                               ;
066A            460   ;---------------------------------;
066A            461   FSM:
066A E54B       462       mov a, FSM_state
066C            463   FSM_state0:
066C B4000F     464       cjne a, #0, FSM_state1
066F 754700     465       mov pwm, #0 ; power variable
0672            466   
0672 300706     467       jnb start_stop_flag, FSM_state0_done
0675 753F00     468       mov seconds, #0     ; set time to 0
0678 754B01     469       mov FSM_state, #1   ; set FSM_state to 1, next state is state1
067B            470   FSM_state0_done:
067B 02066A     471       ljmp FSM    ;jump back to FSM and reload FSM_state to a
067E            472   
067E            473   FSM_state1:
067E B40154     474       cjne a, #1, FSM_state2
0681 754764     475       mov pwm, #100
0684 C0E0       476            push acc
0686 7401       476            mov a, #1
0688 14         476            dec a
0689 12010B     476            lcall ?Set_Cursor_2 ; Select column and row
068C D0E0       476            pop acc
068E C083       477            push dph
0690 C082       477            push dpl
0692 C0E0       477            push acc
0694 900025     477            mov dptr, #Ramp_to_soak
0697 120100     477            lcall ?Send_Constant_String
069A D0E0       477            pop acc
069C D082       477            pop dpl
069E D083       477            pop dph
06A0 C3         478       clr c
06A1 300725     479       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
06A4 7460       480       mov a, #0x60
06A6 953F       481       subb a, seconds
06A8 4013       482       jc abort
06AA            483   continue:
06AA C3         484       clr c   ; ! i don't know what is c
06AB E545       485       mov a, soak_temp    ; set a to soak temp
06AD 853848     486            mov temp, bcd
06B0 9548       487       subb a, temp    ; temp is our currect temp
06B2 5006       488       jnc FSM_state1_done
06B4 753F00     489       mov seconds, #0     ; set time to 0
06B7 754B02     490       mov FSM_state, #2
06BA            491   FSM_state1_done:
06BA 02066A     492       ljmp FSM
06BD            493   abort:
06BD 7432       494       mov a, #50  ; set a to 50 degree
06BF 853848     495            mov temp, bcd
06C2 9548       496       subb a, temp
06C4 40E4       497       jc continue     ; if temp is larger then 50 degree, go back to continue
06C6 754B00     498       mov FSM_state, #0   ; abort the FSM
06C9            499   
06C9            500   stop_state:
06C9 C2CA       501       clr TR2
06CB 300705     502       jnb start_stop_flag, stop
06CE D2CA       503            setb TR2
06D0 02066A     504            ljmp FSM
06D3            505   
06D3            506   stop:
06D3 80F4       507       sjmp stop_state
06D5            508   
06D5            509   FSM_state2:
06D5 B40232     510       cjne a, #2, FSM_state3
06D8 754714     511       mov pwm, #20
06DB E544       512       mov a, soak_time    ; set a to soak time
06DD C0E0       513            push acc
06DF 7401       513            mov a, #1
06E1 14         513            dec a
06E2 12010B     513            lcall ?Set_Cursor_2 ; Select column and row
06E5 D0E0       513            pop acc
06E7 C083       514            push dph
06E9 C082       514            push dpl
06EB C0E0       514            push acc
06ED 900036     514            mov dptr, #Soak_display
06F0 120100     514            lcall ?Send_Constant_String
06F3 D0E0       514            pop acc
06F5 D082       514            pop dpl
06F7 D083       514            pop dph
06F9 C3         515       clr c   ; ! i don't know what is c 
06FA 3007CC     516       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
06FD 953F       517       subb a, seconds    ; temp is our currect sec
06FF 5006       518       jnc FSM_state2_done
0701 753F00     519       mov seconds, #0     ; set time to 0
0704 754B03     520       mov FSM_state, #3
0707            521   FSM_state2_done:
0707 02066A     522       ljmp FSM
070A            523   
070A            524   FSM_state3:
070A B4033B     525       cjne a, #3, FSM_state4
070D 754764     526       mov pwm, #100
0710 E543       527       mov a, reflow_temp    ; set a to reflow temp
0712 C0E0       528            push acc
0714 7401       528            mov a, #1
0716 14         528            dec a
0717 12010B     528            lcall ?Set_Cursor_2 ; Select column and row
071A D0E0       528            pop acc
071C C083       529            push dph
071E C082       529            push dpl
0720 C0E0       529            push acc
0722 900044     529            mov dptr, #Ramp_to_peak
0725 120100     529            lcall ?Send_Constant_String
0728 D0E0       529            pop acc
072A D082       529            pop dpl
072C D083       529            pop dph
072E C3         530       clr c   ; ! i don't know what is c 
072F 300797     531       jnb start_stop_flag, stop_state ; checks the flag if 0, then means stop was pressed, if 1 keep on going
0732 853848     532            mov temp, bcd
0735 9548       533       subb a, temp    ; temp is our currect temp
0737 5006       534       jnc FSM_state3_done
0739 753F00     535       mov seconds, #0     ; set time to 0
073C 754B04     536       mov FSM_state, #4
073F            537   FSM_state3_done:
073F 02066A     538       ljmp FSM
0742            539            
0742            540   intermediate_state_0:
0742 02066C     541            ljmp FSM_state0
0745            542   
0745            543   intermediate_stop_jump:
0745 0206C9     544            ljmp stop_state
0748            545   
0748            546   FSM_state4:
0748 B40432     547       cjne a, #4, FSM_state5
074B 754714     548       mov pwm, #20
074E E542       549       mov a, reflow_time    ; set a to reflow time
0750 C0E0       550            push acc
0752 7401       550            mov a, #1
0754 14         550            dec a
0755 12010B     550            lcall ?Set_Cursor_2 ; Select column and row
0758 D0E0       550            pop acc
075A C083       551            push dph
075C C082       551            push dpl
075E C0E0       551            push acc
0760 900055     551            mov dptr, #Reflow_display
0763 120100     551            lcall ?Send_Constant_String
0766 D0E0       551            pop acc
0768 D082       551            pop dpl
076A D083       551            pop dph
076C C3         552       clr c   ; ! i don't know what is c 
076D 3007D5     553       jnb start_stop_flag, intermediate_stop_jump; checks the flag if 0, then means stop was pressed, if 1 keep on going
0770 953F       554       subb a, seconds    ; temp is our currect sec
0772 5006       555       jnc FSM_state4_done
0774 753F00     556       mov seconds, #0     ; set time to 0
0777 754B05     557       mov FSM_state, #5
077A            558   FSM_state4_done:
077A 02066A     559       ljmp FSM
077D            560   
077D            561   FSM_state5:
077D B405C2     562       cjne a, #5, intermediate_state_0
0780 754700     563       mov pwm, #0
0783 743C       564       mov a, #60    ; set a to 60
0785 C0E0       565            push acc
0787 7401       565            mov a, #1
0789 14         565            dec a
078A 12010B     565            lcall ?Set_Cursor_2 ; Select column and row
078D D0E0       565            pop acc
078F C083       566            push dph
0791 C082       566            push dpl
0793 C0E0       566            push acc
0795 900064     566            mov dptr, #Cooling_display
0798 120100     566            lcall ?Send_Constant_String
079B D0E0       566            pop acc
079D D082       566            pop dpl
079F D083       566            pop dph
07A1 C3         567       clr c   ; ! i don't know what is c
07A2 3007A0     568       jnb start_stop_flag, intermediate_stop_jump ; checks the flag if 0, then means stop was pressed, if 1 keep on going 
07A5 853848     569       mov temp, bcd
07A8 9548       570            subb a, temp    ; temp is our currect temp, need to be edit
07AA 5006       571       jnc FSM_state5_done
07AC 753F00     572       mov seconds, #0     ; set time to 0
07AF 754B00     573       mov FSM_state, #0
07B2            574   FSM_state5_done:
07B2 02066A     575       ljmp FSM
07B5            576   EN
